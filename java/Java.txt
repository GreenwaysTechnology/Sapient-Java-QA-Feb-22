                                         Java
..............................................................................................

JDK 11 - https://www.oracle.com/in/java/technologies/javase/jdk11-archive-downloads.html
Download IntelliJ IDEA - https://www.jetbrains.com/idea/download/#section=windows
Maven - https://maven.apache.org/download.cgi
.............................................................................................
				Java
.............................................................................................

What is java ? Term Java ?
 
 Java is technology.

What is Technology?
 Solving practical Problems in the real world.

What type of problem java was trying to solve? Why Java?

 SUN Micro System is the leading hardware and electronics manfacturing company in USA.

1988 - SUN setup an RND division to develop new technology for their hardwares, before that SUN was using c and c++ was the primary language for building apps. SUN decided to move out from c and c++.

C working model:

hello.c

#include<stdio.h>

void main(){
  printf("Hello");
}
 |
hello.out - Unix - Compiled code- assembly language.

Role of compiler:
1.To generate os specific code
2.Finding Syntax error
 
#include<stdio.h>

void main(){
  printf("Hello"); // api /lib/ built in function
}
void printf(char* text,int offset...){
   //which os system call
   unix_printf(text,01,10...);
}

|
Executed on OS.
|
Runtime - Program which runs the other program, Every program must have runtime.
|
loads the assembly(compiled code) into RAM(Main Memory)
|
Code is now running

.............................................................................................
Problems of c and C++.

1.if you build application using c++ on unix operating system, the same application we cant reuse on windows.
  =>many apis were built os specific.

eg:
  on windows i have an api called
 
   clearScreen() 

 The same api may not be available in Unix.

2.compiled code cant be resued across multiple operating system.


3. lot of complexity in the code.
   =>Pointers- which leaks security
   =>Threads creation was very complex.
   =>Datastructure

SUN MicroSystem who wanted to create a new Programming langugage to solve c++ issues

 =>Portablity -  Platform independant Programming lanugage

Under James Golsing, who was chief scientist, asked to create new Programming lanugage.

James and his team started working on new Programming lanugage.

=>The language was initially called Oak after an oak tree that stood outside Gosling's office. Later the project went by the name Green and was finally renamed Java, from Java coffee, a type of coffee from Indonesia.

1988 -1989 -  OAK.

OAK failed with respect to 100 portablity.

1989 - James conviced a concept called "Virtual Computing", by looking the white paper published in 1974.
 A "virtual machine" was originally defined by Popek and Goldberg as "an efficient, isolated duplicate of a real computer machine.

James got an idea , why we should create programs for real computer,rather we create virutal computer, on which we can run program.

As result of that James invented /created a virtual Operating(simulating real Operating System).

Real Operating like windows,linux.

James created an operating system called "Virtual Machine", after creating Virtual machine 
who renamed the language and also added some modification on OAK- 
  Java Programming language
  Java Virtual Machine

                         "Write once run any where"

He developed the complete technolgy which contains tools

called:

 1.JVM
 2.language apis - JDK
 3.compiler - javac 
 4.other tools
 5.java is for running code.
 6.JRE - java Runtime Environment - Which contains jvm,libs

How JVM has been built?

  JVM is simple c program only.
.............................................................................................

Java Application development:
Requirements

1.JDK 
2.IDE

JDK contains all tools for development and testing apps

1.javac compiler for compiling source code into assembly

2.java command for running code.

.............................................................................................
Once the application has been built , it moves to production or testing env.

We need only JRE - Java Runtime env.

Which contains

1.jvm
2.runtime libs
..............................................................................................
				Java Programming language
..............................................................................................

What is Java Programming language?
  Java Programming language is object oriented,functional style programming language.
  
Java Programming language features:
...................................
 
=>Simple and Familiar.
=>Platform Independent/Portable
=>Architectural Neutral
=>Object-Oriented && Functional style
=>Robust
=>Secure - it does not allow pointers

Java was released in 1996 for public as open source technology.
.............................................................................................
Java entered in the many parts of software development particullary who played vital role in web development.
Java started growing vast, SUN decided to organize the java into three major editions

=> JSE -  Java standard Edition
   Covers core language features
=> JEE -  Java Enterprise Edition
   Web and distributed application Development
=> JME -  Java Micro Edition
   Card,Mobile

Who is developing java technology? and who is controlling java?

In the begining, SUN ,later java was acquired by Oracle, now java with Oracle.

Even though Oracle is developing and managining java, who cant controll fully , who is controlling.

Java Community Process:https://www.jcp.org/en/home/index
............................................................................................

All java technology is based on specification only. The first JCP writes a specifcation which document how technology looks like.

Any people can write implementation for the specification, 

Major Spec and its implementation.

JVM Spec:
 -Oracle JVM/Sun Hot Pot JVM
 -Open JDK JVM

Language spec and implemenation
  -Oracle

..............................................................................................

Java Programming language Learning path:

1.language fundamentals
   -variables,datatypes,literals
   -conditional statements 
   -loops
2.Object oriented programming and implementation

3.Exception Handling

4.How to work with IO

5.How to work with databases

6.DataStructure in java Collections

7.Multi Threading

1.language fundamentals:

How to setup java project?

-Plain java project
-Java project using build systems
  ->ant - very old, nobody is using now a days
  ->Maven
  ->Gradle
..............................................................................................
1.language fundamentals
   -variables,datatypes,literals
   -conditional statements 
   -loops

HelloWorld.java
  javac HelloWorld.java

java is class based object oriented programming language. so every program must start with 
class.

Poniters:

=>We can create n-number of classes
=>There must be only one main class, which starts your application
=>The class Containing main method, called main class.
=>Single java application must have only one main class.

Program types:

1.source code , FileName.java

2.compiled code FileName.class
  -class file
  -byte code 
 Assembly code , is portable across multiple os where ever jvm is present.
..............................................................................................

Modularity:

  breaking the code into files and folders, and organized based on some standards
  In java modularity is implemented via packages.

What is Package?

  logical and physical organization of java source and compiled code into folders and files.
   
  package is collection of classes and sub packages.

Every java class must begin with package.

package packagename

if there is no package statement, then it uses default package, but it is not recommended.


eg:
public class HelloWorld {
    //main method
    public static void main(String args[]) {
        //print some text on console
        System.out.println("Hello World Java");
    }
}

How to introduce package?

package com.sapient.core

as soon as if you introduce package, java compiler creates folder in the filesystem

E:\session\sapient\Java-QA\javaapps\src\main\java\com\sapient\core


package com.sapient.core;

public class HelloWorld {
    //main method
    public static void main(String args[]) {
        //print some text on console
        System.out.println("Hello World Java");
    }
}
 
Types of packages:

1.java built in packages
  java language offers lot of packages which provides api to write java application
java language package starts with
 java.lang
 java.util
 java.net
 javax.xml

Note: java and javax cant be used for our own packages -  Reserved packages

2.custom packages
  Packages created for project specific.

custom packages starts with
com.
org.
Why it starts with com and org?
 =>It is standard way of defining packages. - Coding standards

com - means company
org - organization

any commerical projects starts with "com", where as any open source projects starts "org"

com                 .sapient      .core
 |                     |            |
commerical project  company Name  Project module

com.sapient.hr.    admin;
             |       |
         main module submodule

org.apache.tomcat.server


3.Third party packages
   
 Packages distributed by thrid parties, so that we can use those packages in our applications

frameworks and libs are examples of third party

 spring framework
 junit
 mockito
etc...  

How to use the packages? to be discussed latter.
..............................................................................................

Language fundamentals:

1.data types,variables and literals

Data types:

 Java is strongly typed/static typed programming language.
 The type of variable is decided during compile time.

Data types classification:

1.primitive data types
2.reference data types/Object types

1.primitive data types

numbers
 byte,short,int,long -  whole number
Each data type has its own size.

byte:
 The byte data type is an 8-bit signed two's complement integer. It has a minimum value of -128 and a maximum value of 127 (inclusive) 

short: The short data type is a 16-bit signed two's complement integer. It has a minimum value of -32,768 and a maximum value of 32,767 (inclusive)

int: By default, the int data type is a 32-bit signed two's complement integer, which has a minimum value of -231 and a maximum value of 231-1.

long: The long data type is a 64-bit two's complement integer. The signed long has a minimum value of -263 and a maximum value of 263-1

float,double -  precision values

float: The float data type is a single-precision 32-bit IEEE 754 floating point.
double: The double data type is a double-precision 64-bit IEEE 754 floating point

chars 
 char 
The char data type is a single 16-bit Unicode character.

boolean
  The boolean data type has only two possible values: true and false. This data type represents one bit of information, but its "size" isn't something that's precisely defined.


2.Rerference types
  Size of reference types cant be fixed, collection of other types, which is calculated dynamically.

Object types
String - collection of character

..............................................................................................

Literals:
  values are stored inside variable

Integer literals:
 ->decimal -  26;
 ->hexa decimal -0x1a;
 ->binary - 0b11010;

Floating point literals
 ->10.4f/F  - floating points
 ->10.4 -double literal

String literals:
  Collection of strings
  "hello"
Character literals
  Single character
  'A'
boolean literals 
  true 
  false
.............................................................................................

Variables:
  Place holder which holds/refers the literals
variables can store prmiitive values or reference values(objects).

Variables are classified into various category:

1.local variables and args variables
  Variables are declared with any type(primitive/reference), with in method
2.instance variables
   variables are declared inside class
   instance variables can be any type (primitive/reference)
3.static variables 
    Variables are declared inside class with static keyword
   instance variables can be any type (primitive/reference
..............................................................................................

package com.sapient.core;

public class PrimitiveDataTypes {
    public static void main(String[] args) {
        //variables
        //whole numbers
        byte byteVariable = 10;
        short shortVariable = 199;
        int intVariable = 9000;
        long longVariable = 900;
        System.out.println("Whole Numbers : Integer");
        System.out.println("Byte " + byteVariable);
        System.out.println("Short " + shortVariable);
        System.out.println("Int  " + intVariable);
        System.out.println("Long " + longVariable);
        //literals
        //decimal number
        //hexa decimal
        //octal numbers
        // The number 26, in decimal
        int decVal = 26;
//  The number 26, in hexadecimal
        int hexVal = 0x1a;
// The number 26, in binary
        int binVal = 0b11010;
        System.out.println("Decimal Literal " + decVal);
        System.out.println("Hexa Decimal " + hexVal);
        System.out.println("binValue " + binVal);

        System.out.println("Precision Numbers : Floating points");
        float floatVariable = 10.5f;
        double doubleVariable = 90.78;
        System.out.println("Float  " + floatVariable);
        System.out.println("Double " + doubleVariable);
        //chars
        System.out.println("Characters : Single Char");
        char c = 'a';
        System.out.println("Char  " + c);
        //collection of Characters
        System.out.println("Characters : multi Char");
        String stringVariable = "hello";
        System.out.println("Strings  " + stringVariable);
        //boolean
        System.out.println("Boolean : true/false");
        boolean booleanVariable = true;
        System.out.println("Boolean  " + booleanVariable);


    }
}
...........................................................................................
				Underscores literals

Using Underscore Characters(_) in Numeric Literals

package com.sapient.core;

public class UnderscoreLiterals {
    public static void main(String[] args) {
        long creditCardNumber = 1234_5678_9012_3456L;
        long socialSecurityNumber = 999_99_9999L;
        float pi =  3.14_15F;
        long hexBytes = 0xFF_EC_DE_5E;
        long hexWords = 0xCAFE_BABE;
        long maxLong = 0x7fff_ffff_ffff_ffffL;
        byte nybbles = 0b0010_0101;
        long bytes = 0b11010010_01101001_10010100_10010010;
        System.out.println(socialSecurityNumber);
        System.out.println(creditCardNumber);

    }
}

You can place underscores only between digits; you cannot place underscores in the following places:

At the beginning or end of a number
Adjacent to a decimal point in a floating point literal
Prior to an F or L suffix
In positions where a string of digits is expected
..............................................................................................
				 Operators
..............................................................................................

Most of the Operators are dervied from c / c++ :
.................................................

The Arithmetic Operators
+	Additive operator (also used for String concatenation)
-	Subtraction operator
*	Multiplication operator
/	Division operator
%	Remainder operator

package com.sapient.core;

public class OperatorsDemo {
    public static void main(String[] args) {
        int result = 1 + 2;
        // result is now 3
        System.out.println("1 + 2 = " + result);
        int original_result = result;

        result = result - 1;
        // result is now 2
        System.out.println(original_result + " - 1 = " + result);
        original_result = result;

        result = result * 2;
        // result is now 4
        System.out.println(original_result + " * 2 = " + result);
        original_result = result;

        result = result / 2;
        // result is now 2
        System.out.println(original_result + " / 2 = " + result);
        original_result = result;

        result = result + 8;
        // result is now 10
        System.out.println(original_result + " + 8 = " + result);
        original_result = result;

        result = result % 7;
        // result is now 3
        System.out.println(original_result + " % 7 = " + result);
    }
}
.............................................................................................
The Unary Operators
   single operand.
 ++
The binary operators
   two operand
  a + b

+	Unary plus operator; indicates positive value (numbers are positive without this, however)
-	Unary minus operator; negates an expression
++	Increment operator; increments a value by 1
--	Decrement operator; decrements a value by 1
!	Logical complement operator; inverts the value of a boolean

package com.sapient.core;

public class UnaryOperators {
    public static void main(String[] args) {
        int result = +1;
        // result is now 1
        System.out.println(result);

        result--;
        // result is now 0
        System.out.println(result);

        result++;
        // result is now 1
        System.out.println(result);

        result = -result;
        // result is now -1
        System.out.println(result);

        boolean success = false;
        // false
        System.out.println(success);
        // true
        System.out.println(!success);
    }
}
..............................................................................................

The Equality and Relational Operators

==      equal to
!=      not equal to
>       greater than
>=      greater than or equal to
<       less than
<=      less than or equal to

All operators here , gives boolean result, like true or false.
package com.sapient.core;

public class RealtionalOperator {
    public static void main(String[] args) {
        int value1 = 1;
        int value2 = 2;
        if(value1 == value2)
            System.out.println("value1 == value2");
        if(value1 != value2)
            System.out.println("value1 != value2");
        if(value1 > value2)
            System.out.println("value1 > value2");
        if(value1 < value2)
            System.out.println("value1 < value2");
        if(value1 <= value2)
            System.out.println("value1 <= value2");
    }
}
.............................................................................................
Conditional  Operator:

&& Conditional-AND
|| Conditional-OR
?: Tenary operator

package com.sapient.core;

public class ConditionalOperator {
    public static void main(String[] args) {
        int value1 = 1;
        int value2 = 2;
        if((value1 == 1) && (value2 == 2))
            System.out.println("value1 is 1 AND value2 is 2");
        if((value1 == 1) || (value2 == 1))
            System.out.println("value1 is 1 OR value2 is 1");
        //tenary opertor
        boolean someCondition = true;
        String result = someCondition ? "Hello" : "How are you?";

        System.out.println(result);

    }
}
.............................................................................................
				 Other operators

1.new Operator -  memory allocation operator
2.instanceof operator - type verification operator
..............................................................................................
Expressions, Statements, and Blocks,Control Statements:
.......................................................

Expression:
 An expression is a construct made up of variables, operators, and method invocations, which are constructed according to the syntax of the language, that evaluates to a single value

eg:
   int result = 10 *10(expression)
   int result  = calculate();

Statements:
 Statements are roughly equivalent to sentences in natural languages. A statement forms a complete unit of execution. 

1.Assignment expressions
2.Any use of ++ or --
3.Method invocations
4.Object creation expressions

// assignment statement
aValue = 8933.234;
// increment statement
aValue++;
// method invocation statement
System.out.println("Hello World!");
// object creation statement
Bicycle myBike = new Bicycle();

Blocks:
A block is a group of zero or more statements between balanced braces and can be used anywhere a single statement is allowed.

if(condition) {
  //block
}
//instance block

class A {
   
   {}
  
}
//static block
class A {
   static {}
  
}
..............................................................................................
The if-then and if-then-else ,if--elseif---else Statements

The if-then Statement without else statement:
..............................................
package com.sapient.core;

public class IFControlFlowStatement {
    public static void main(String[] args) {
        boolean isMoving = true;
//        if (isMoving){
//            System.out.println("Moving...");
//        }
        if (isMoving) System.out.println("Moving...");
        
    }
}

if...else
package com.sapient.core;

public class IFControlFlowStatement {
    public static void main(String[] args) {
        boolean isMoving = true;
       //if...else
        if (isMoving) {
            System.out.println("Moving...");
        } else {
            System.err.println("The bicycle has already stopped!");
        }

    }
}

if...else if ..else
 int testscore = 76;
        char grade;

        if (testscore >= 90) {
            grade = 'A';
        } else if (testscore >= 80) {
            grade = 'B';
        } else if (testscore >= 70) {
            grade = 'C';
        } else if (testscore >= 60) {
            grade = 'D';
        } else {
            grade = 'F';
        }
        System.out.println("Grade = " + grade);

..............................................................................................

Switch ...case:
  Unlike if-then and if-then-else statements, the switch statement can have a number of possible execution paths. 
A switch works with the byte, short, char, and int primitive data types,even enums also


package com.sapient.core;

public class SwitchCaseDemo {
    public static void main(String[] args) {
        //switch replaces if with multiple equal condtions
        int month = 8;
        String monthString;
        switch (month) {
            case 1:  monthString = "January";
                break;
            case 2:  monthString = "February";
                break;
            case 3:  monthString = "March";
                break;
            case 4:  monthString = "April";
                break;
            case 5:  monthString = "May";
                break;
            case 6:  monthString = "June";
                break;
            case 7:  monthString = "July";
                break;
            case 8:  monthString = "August";
                break;
            case 9:  monthString = "September";
                break;
            case 10: monthString = "October";
                break;
            case 11: monthString = "November";
                break;
            case 12: monthString = "December";
                break;
            default: monthString = "Invalid month";
                break;
        }
        System.out.println(monthString);
    }
}
...........................................................................................
					Loops
...........................................................................................

1.for 
  regular for.
  for..in loop
2.while
3.do..while

package com.sapient.core;

public class LoopsMain {
    public static void main(String[] args) {
        for (int i = 1; i < 11; i++) {
            System.out.println("Count is: " + i);
        }

        int count = 1;
        while (count < 11) {
            System.out.println("Count is: " + count);
            count++;
        }
        //do...while
        int counter = 1;
        do {
            System.out.println("Count is: " + counter);
            counter++;
        } while (counter < 11);
    }
}
..............................................................................................
                  Object oriented Programming and Implementation
..............................................................................................

What is Object orientation?
  It is way of building applications.
  It is style of writing code.
  It was introduced in 1960, became popular in 1970 ,C++.
  The language which follows the object orientation called "Object oriented programming   language"
Object oriented Programming langugages

1.C++
2.Java
3.C#
etc....

What is Object?
   "Every thing in this universe Object but which should be relvant to the Problem Domain/Space".

Eg:
   I am doctor, according to the doctor brian cell is object, but as a normal person 
 we dont understand about brain cell, we have not seen that.
 
As object oriented developer, we represent objects in the software domain as it is.

Object contains three things

1.state - information associated with object
2.behaviour -  methods which change the information
3.identity - to identify the object uniquly

..............................................................................................
			Objects and software systems

Software intention is to store information(data),process them,produce them.

Software design is all about how we capture the information/data, how to represent them.

Programming lanugages capture data, organize them, process them.

Programming language follows object models , which captures the data as it is in the real world.

When we capture and represent the data, we need classification. "class" -  class is core concept which capture data,how to process them.
..............................................................................................
Object oriented Concepts/principles:
....................................

1.Abstraction
2.Encapsulation
3.Hierarchy
    inheritance
    has-a -composition
4.Typing
   polymorphism
5.Modularity
6.Concurrency
7.Persistency

The language which implements these 7 principles called object oriented programming langugage.

Java has implemented all these principles.
............................................................................................
				 Object Modeling Process
............................................................................................

Object oriented Any and design

Steps :

1.Identify objects in the realtime/problem Domain. 
 eg:Banking
          Customer,Account,Loan,Employee.....


2.Appling Abstraction
   Abstraction is nothing but take necessary details from the problem domain,give up unncessary details.
 eg:
 if you go to hospital, you are now patient, now hostipal need collect only health related information not your educational details,not your personal information.

How to apply abstraction in code(java)?
 class

java syntax;

 public | package class ObjectName {
    //data - via variables with types
    //behaviour - how to change the data
    //identity  - special variable to identitfy the object
 }

What is object?

 There are two views

1.In the Problem domain
     Customer,Account,Employee
2.In the Program domain
     Object is other wise called as "instance".
   Object represent memory.
   Object means collection of variabl's memory.

  Type(className) variableName(pointer to memory address-reference)= new ClassName(); //instance /object creation
.............................................................................................
					Data types

Computer can understand only one type - number (0/1)

How to represent other information in computer?

1.Numbers
 whole - 10
 precision -10.5
2.NonNumbers
  text
  images
  videos
  sounds

In CS, data types can be two things

1.prmitives -  core types
  number,characters
  byte,int,short,long,double,float,char ,boolean

2.Custom Types
   using core types we can create custom types
 classes are used to create custom types

 class Customer {
      //state-data
    int id; //identity
    String name;
    double invoiceValue;
    String city;
 }

 Here Customer is a type, which contains other types -  {int,String,double,String}

  Customer =  {int,String,double,String}

 new Operator - used to allocate memory for custom type.
 Constructor - it is special method/function provided by language to initiate memory allocation.

 Customer customer = new Customer();
  |        |         |       |
 Type    variable   operator constructor call

Using reference variable, we can access object properties (state,behaviour,identity).

Java gives "." (dot) operator to access object properties.


package com.sapient.oo.abstraction;

public class Customer {
    //state-data
    int id=1; //identity
    String name="Subramanian";
    double invoiceValue=100.89;
    String city="Coimbatore";
    //
}

package com.sapient.oo.abstraction;

public class ObjectCreationMain {
    public static void main(String[] args) {
        Customer customer = new Customer();
        System.out.println("Id :" + customer.id);
        System.out.println("Name " + customer.name);
        System.out.println("City " + customer.city);
        System.out.println("Invoice Value " + customer.invoiceValue);
    }
}
.............................................................................................
				 Object Behaviour
..............................................................................................

What is method?

method is nothing but unit of computation.
Which performes computation.
Which mutates(change) the state(updating the variable value).

syntax:

 AccessModifer | nonAccessModifer ReturnType methodName(arg){
  //method body
  //return statement
}
package com.sapient.oo.object.behaviour;

public class Car {
    //state
    int speed = 0;
    int gear = 0;

    void start() {
        //mutation changing
        speed = 5;
    }

    void changeGear(int gear) {
        this.gear = gear;
        switch (this.gear) {
            case 1:
                System.out.println("Pressing exclator ");
                speed = 10;
                break;
            case 2:
                System.out.println("Pressing exclator ");
                speed = 20;
                break;
            case 3:
                System.out.println("Pressing exclator ");
                speed = 30;
                break;
            case 4:
                System.out.println("Pressing exclator ");
                speed = 40;
                break;
            case 5:
                System.out.println("Pressing exclator ");
                speed = 60;
                break;
            default:
                System.out.println("Reverse ");
                speed = 10;
                break;

        }
    }
}
package com.sapient.oo.object.behaviour;

public class CarMain {
    public static void main(String[] args) {
        Car car = new Car();
        //access car initial speed
        System.out.println("Speed :" + car.speed);
        //change the state
        car.start();
        System.out.println("Speed :" + car.speed);
        car.changeGear(4);
        System.out.println("Speed :" + car.speed);

    }
}
..............................................................................................

methods ,args,Parameters and returns

=> can accept any type of args-  primtives,reference Type
=> can return any type 
=> may not return - void 

package com.sapient.oo.object.behaviour;

public class Calculator {
    //with parameters and no return
    void add(int a, int b) {
        int result = a + b;
        System.out.println("Add " + result);
    }
    //with return
    int multiply(int a, int b) {
        return a * b;
    }
}
package com.sapient.oo.object.behaviour;

public class ArgsMain {
    public static void main(String[] args) {
        Calculator calculator = new Calculator();
        //
        calculator.add(10,10);
        System.out.println(calculator.multiply(10,10));
    }
}
..............................................................................................
				Types of Methods
.............................................................................................

Based on How methods are accessed:

1.instance methods
2.static methods/class methods


1.instance methods:
   
  The method declared inside class, instance methods
  instance methods can be accessed only through "reference variable" with having objects.

2.static methods
 
   The method declared inside class with static keyword/modifier
  Static methods are accessed with help of ClassName.
............................................................................................
				static keyword

static keyword can be used with variable declaration and also method declarations.

if variable declared with static , called as "class variables/static variables"
if method is declared with static, called as "class methods/static methods"
............................................................................................
				Memory Allocation - JVM internals
...........................................................................................

What is JVM?
 It is Process, written in c language.

How the process looks like?
 Every process has three segments

->heap
   - for allocating dynamic memory needed by an application
->stack
   - for allocating static memory for methods
   - methods/functions are also require memory.
   - where methods are pushed , for that memory is allocated
   -> methods memory is called "stack frame work"
->program data
   Program code memory is allocated here like literals...

Since JVM is process , it also has structure:

JVM has three segments

1.heap
    Inside heap only all objects are created and living.
2.stack
    all methods are pushed into stack, becomes the stack frame.
    main method is entry method which is pushed at the bottom of the stack
   
    when   method is called
     -> it is pushed into stack
     -> stack creates stack frame
     -> stack framework executes
     -> stack framework is closed
    
3.method area(program data)
   It is global memory area
   Which contains
   ->methods definitions
   ->stack variables
   ->classes memory before object creation/loaded .class file information
   ->literals - (string literals are living inside string constant pool).

 
All instance variables and methods live inside heap(object).

All static variables and methods live inside method Area.
All static variables are initalized during class loading process before object creation.
All static variables and methods are accessed by "className" only.

package com.sapient.oo.staticinfo;

public class Message {
   static String WARNING_INFO ="Warning";
   //static method
    static String getInfo(){
        return "INFO";
    }
}
package com.sapient.oo.staticinfo;

public class StaticMain {
    public static void main(String[] args) {
        System.out.println(Message.WARNING_INFO);
        System.out.println(Message.getInfo());
    }
}
.............................................................................................
				instance methods classification


There are two classification:

1.biz methods

2.accessor/mutator methods


1.biz methods

 represents biz process, which change the state.
public class Car {
    //state
    int speed = 0;
    int gear = 0;

    void start() {
        //mutation changing
        speed = 5;
    }

    void changeGear(int gear) {
        this.gear = gear;
        switch (this.gear) {
            case 1:
                System.out.println("Pressing exclator ");
                speed = 10;
                break;
            case 2:
                System.out.println("Pressing exclator ");
                speed = 20;
                break;
            case 3:
                System.out.println("Pressing exclator ");
                speed = 30;
                break;
            case 4:
                System.out.println("Pressing exclator ");
                speed = 40;
                break;
            case 5:
                System.out.println("Pressing exclator ");
                speed = 60;
                break;
            default:
                System.out.println("Reverse ");
                speed = 10;
                break;

        }
    }
}

2.accessor and mutators:
  setters and getters

are used to set and get instance variables outside the class.

How instance variables  are accessed?

There are different ways

Using reference variable directly
 Employee emp=new Employee();
 emp.id=1

Using reference variable via setters and getters methods

setters are methods used to initalize the data

getters are methods used to read the data.

setter Syntax:
..............

class Employee {
 int id;
 String name;
 public void setId(int id){
   this.id = id;
 }

}

1.Every setter method must have void return type
2.Every setter method must start with set+VaribleName
   -Variable Name must be Camel Case setId()
3.Ever setter method arg must match with instance variable declaration
  int id;
  public void setId(int id){
   this.id = id;
  }
4.instance variables are referenced inside method using "this" keyword
   this.id means you are refering instance variable
   id means here local variable 
   this.id =id means we assign localvariable value to instance variable


setter vs direct Reference?

Coding standards:

  Enforcing code best pratices across the team, company, community.

Java brought lot of common standard, as a java developer we should not viloate the coding standards.


File Name Coding standard:
...........................

1.File Name must be meaning full to the problem.
  a.java - invaild
  xyz.java -invalid

 Employee.java,Customer.java,WithdrawService.java - valid
 
2.File name must be noun.

3.File Name and class Name must match
 
  Employee.java

  public class Employee {}

Class name coding standard:
...........................
1.class Name must be meaningfull to the problem
  Employee -valid
  emp -invalid
2.Class Name must be always nouns only cant be verbs , should start with Capital Letter
  if there is SecondNoun, it should be also capitalized
  Employee,Customer -Nouns
  CustomerService
3.class can be marked public or without public.

instance variable coding standard
...................................

1.instance variables must be meaninful
  int a; -  invalid
  int id;
  String name;
  double salary;

2.instance variables must be nouns
   int id;
   String name;
3. instance variables must be camel cased
   String firstName;

4. instance variables must be marked "private"
   private int id;
   private String name;

5. instance variables must be initalized via
   setters or constructors / setters and constructors but directly
	
   customer.id =10; //invalid
   
public class Employee {
    private String name;
    //instance variables
    private int id;

    public void setId(int id) {
        this.id = id;
    }
    public void setName(String name){
        this.name = name;
    }
}

5. instance variables must be read via
   getters.

   public returnType getVariableName(){
        return instancevariableName
   }

instance method coding standard:
................................

1.methods must be meaningfull
  calculate()
2.methods must start with smallar case
  calculate()
2.methods must be "verbs" , not nouns
  add() -valid
  Addition() - invalid
3.methods may mix verb + noun, noun should start with upper case
   addNumber()
   calculateSalary()
   depositMoney()
  
static variables coding standards:

1.should be capitalized
   WARNING
2.INCASE LONG names,_ should be used
  WARNING_INFO
3.all static variables must be marked public
   public static String WARNING_INFO ="Warning";
4.all static variables can be marked final
   public static final String WARNING_INFO ="Warning";

static methods coding standards

=>similar to instance methods
..............................................................................................
				Java Bean Coding standards

In 1996, SUN introduced coding standard called "java bean coding standards" , in order to declare class, instance variables, how it can be initalized and read.
 setters and getters are part of that javabean standards.
..............................................................................................
					Encapsulation
..............................................................................................

The meaning of Encapasulation is "hidding".

How to share code  and how much code we can share , at what extend we can share?

Code sharing;
 code means classes and its members.

Encapsulation in java is implemented through keywords - access modifiers.

-public
-private
-default(package level)
-protected
 
public means we can share code any where in the application.

class can be public, meaning that it can be accessed any where in the application.

                                 Modularity

Java applications are classified into modules callead as packages.

Each package defines a boundry for classes

public: 
  can be accessed with in package.
  can be accessed outside the package.
public classes:
  
Use case 1 : within package.

package com.sapient.enc.pub;

public class Employee {
}

package com.sapient.enc.pub;
public class EmployeeMain {
    public static void main(String[] args) {
        Employee employee = new Employee();
    }
}

Use case 2: Outside package

if classes are in the different packages, we have to import them.


package com.mycom.example;

import com.sapient.enc.pub.Employee;

public class EmployeeMain {
    public static void main(String[] args) {
        Employee employee = new Employee();
    }
}

syntax of import:

import com.sapient.enc.pub.*; => import or link all the classes defined inside this package
    
import com.sapent.enc.pub.Employee => import only Employee class defined inside this package
  -This is recommended

Rule for import:

if classes are defined inside the same package, you dont need to use "import" statement to link classes, java does automatically.

com.sapient.core
class Employee{}

com.sapient.core
class Main{
  main{
    Employeee employee=new Employee();
  }
}

if classes are in the different package , only you have to import.
..............................................................................................
				public instance variables and methods
..............................................................................................

we can declare public instance variables, but it is not recommended as per java bean coding standard.

package com.sapient.enc.pub;

public class Customer {
    public int id;
}

we can declare public instance methods.

public class Customer {
    public int id;
    public void save(){
        System.out.println("save");
    }
}
we can declare public constructors : to be dicussed later
...........................................................................................
				 private

private means not possible to share outside the class.

class and private:

 classes cant be marked private

private class Employee {
} //error

private instance variables and methods

-private variables cant be accessed outside the class

public  class Employee {
    private int id;
    
}
Note: all instance variables must be marked private as per java coding standard.

private instance methods:
..........................

-> methods can be marked private, can be accessed outside class.
   Private methods are used to encapuslate internal logic of object.
package com.sapient.enc.pri;

public class Authentication {
    private String username;
    private String password;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    //
    public boolean login() {
        //access the private method
        return auth();
    }
    private boolean auth(){
        if (this.username == "admin" && this.password == "admin") return true;
        return false;
    }
}
package com.sapient.enc.pri;

public class Main {
    public static void main(String[] args) {
        Employee employee =new Employee();
      //  employee.id
        Authentication authentication = new Authentication();
        authentication.setUsername("admin");
        authentication.setPassword("admin");
        String res = authentication.login() ? "Login success" : "Login failed";
        System.out.println(res);
    }
}

priavate constructors : to be discussed 
..............................................................................................
			static variables and methods, with private and public


static variables can be marked public : this is always coding standard
   public static final String WARNING_INFO ="Warning";

static methods can also can be marked public
   public  static String getInfo(){
        return "INFO";
   }

static variables can be marked private in certain conditions only.
..............................................................................................
				default modifier

if any to be restricted with in the package only, then it called package level modifer.

in order to declare package level , there is no explicit keyword,no keyword is presented

class and default modifier:

class Employee{}
 here no keyword in front of class.

valid code
package com.sapient.enc.def;

//in default scope
class Employee {
    private  int id;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }
}
package com.sapient.enc.def;

public class Main {
    public static void main(String[] args) {
        Employee employee = new Employee();
        employee.setId(10);
        System.out.println(employee.getId());
    }
}

Invalid access:

package com.sapient.enc.def.subpack;
//'com.sapient.enc.def.Employee' is not public in 'com.sapient.enc.def'. 
// Cannot be accessed from outside package
import com.sapient.enc.def.Employee;
public class Main {
    public static void main(String[] args) {

    }
}

You can declare class package level based on your application use cases.

instance variables and methods:

We can declare instance variables and methods package level.

if class is public but variables and methods are default, 
   "You can access only class but not variables and methods.

static variables and methods are also can be declared default scope.
..............................................................................................
				state initalization
.............................................................................................

state can be initized in three ways

1.hardcoded inside class.

2.after object creation
  2.1.using reference variable- not recommened
  2.2.using setters

3.durating object creation
  constructors



1.hardcoded inside class.
package com.sapient.oo.state.init;

public class Employee {
    private int id = 1;
    private String name = "Subramanian";

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
package com.sapient.oo.state.init;

public class Main {
    public static void main(String[] args) {
        Employee employee=new Employee();
        System.out.println(employee.getId() + " => " + employee.getName());
    }
}

Here the output would be 1 ,Subramaian
............................................................................................

What if i dont initalize the instance variables directly or setters /constructors?

class Employee
 private int id;
 private String name;
}

Java provide default values based on data types.

for integer data types(byte,short,int,long) => 0
for floating point types (float,double) => 0.0
for boolean => false
for char -> `\u0000'

For any reference types
String
Employee
Address    -> null

implicit default values provided by java, where as explicit default values provided by developer inside class or using setter or using constructors.
..............................................................................................

2. After object creating

incase if the variable is not private then we can reinitalize the variable 
using reference variable

employee.city = "coimbatore";
        System.out.println(employee.city);
        employee.setCity("Coimbatore");
        System.out.println(employee.getCity());
..............................................................................................
                3. During object creation : constructors


What is constructors 

  Constructors  are special method used to initialize the state during object creation.


How to declare constructor?

Employee.java

class Employee {}


Here no constructors? 
  if you dont provide constructor, the java will provide constructor automatically which is called "default constructor"
  After compilation, the compiler will add constructor automatically.

Employee.class
public class Employee {
   
    public Employee() {
    }
}

Syntax: 
=> constructor name and class name must match
=> constructor can be private , public,default
=> constructors can take args, where we can initalze the state.

Explicit constructors:
......................

public class Customer {
    private int id;
    private String name;

    //constructor - no arg constructor
    public Customer() {
        this.id = 10;
        this.name = "foo";
    }
}

Employee emp = new Employee();
			|
                    Constructor call

parameterized constructor:
  state can be initalized in different ways.

Constructor overloading:
   Having different constructors, and initalizing the state according to our neeed.

eg:
  i want to pass only id, then we can use one constructor
  i want to pass id and name, then we can use another constructor

Constructors are differentiated by type and order of the type, not by names, 

valid;

public class Customer {
    private int id;
    private String name;
    private String city;

  //two args
    public Customer(int id, String name) {
        this.id = id;
        this.name = name;
    }

    //only Name
    public Customer(String name){
        this.name = name;
    }
    public Customer(String city,int id){
        this.city = city;
    }
}

invalid
public class Customer {
    private int id;
    private String name;
    private String city;

  //two args
    public Customer(int id, String name) {
        this.id = id;
        this.name = name;
    }
    public Customer(int id,String city){
        this.city = city;
        this.id =id;
  
    }
}
.............................................................................................
			constructors vs setter

Both are valid and good.

=>constructors are used to initalize during object creation - eager initalization
=>setters are used to initalize the object after its creation -  lazy intialzation.
.............................................................................................
				this keyword
.............................................................................................

Reference variable:

 It is variable which refers the location of Object.

Employee emp = new Employee();

emp-> reference variable

Types of Reference variables:
............................

1.Emplicit reference variable
 The reference variable declared and assinged in the code by the developer

Employee emp = new Employee();

 emp-> Explicit reference variable


2.implicit reference variable
 
 The reference variable assinged by compiler during compile time and used by jvm during runtime.

 "this" and "super" are reference variables assinged by compiler.

 "this"
    =>just variable points to the current object. 

Every object in java , has "this" reference variable.
..............................................................................................
			When we can use "this" variable
............................................................................................

There are contexts:

1.inside setter method to differentiate local variable and instance variable, which avoids ambiquity.


public class Employee {
    private int id;

    public void setId(int id) {
        id = id;
    }

    public int getId() {
        return id;
    }
}
 Employee employee = new Employee();
        employee.setId(100);
        System.out.println(employee.getId());

What will be output?

 here - 0

why because, instance variable id , not initalized with 100

 public void setId(int id) {
        id = id;
    }
here the compiler has confusion over left and right side. here leftside(id) and rightside(id)
is treated as same.but we are accessing instance variable via getter.

in order to avoid this ambiquity, we need to differentiate local variable and instance variable by using this keyword explicitly.


2.inside constructors to differentiate local variable and instance variable, which avoids ambiquity.

    public Employee(int id){
        this.id = id;
    }

3.Calling constructors.

constructors can be called in two ways:

1.using new Keyword
   new Employee()

2.using "this" keyword inside class only

package com.sapient.oo.object.state.thiskeyword;

public class Customer {
    private int id;
    private String name;

    //default constructor
    public Customer() {
//        this.id =1;
//        this.name ="foo";
        //call two arg constructor : constructor chaining
        this(1, "foo");
    }

    public Customer(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
package com.sapient.oo.object.state.thiskeyword;

public class ThisMain {
    public static void main(String[] args) {
        Employee employee = new Employee(1);
        employee.setId(100);
        System.out.println(employee.getId());
        //
        Customer customer = new Customer();
        System.out.println(customer.getId() + " " + customer.getName());
    }
}

constructor chaining:
  Calling constructors from the constructors  using this called "constructor chaining".
.............................................................................................
			     private constructors


constructors can be marked private 

public class Container {
    private Container() {
        System.out.println("Container is created");
    }
    public String getInfo() {
        return "Container";
    }
}

  Container container = new Container(); //calling constructor
  System.out.println(container.getInfo());

Compiler error:
'Container()' has private access in 'com.sapient.oo.object.state.constructors.priv.Container'

if you mark constructor private, you cant create object, then cant access any thing outside.

but what if i want to create object and access methods and variables even though constructor is marked.

There is some pattern:

1.you have declare public static method.
2.The method must return "Type of the same class"
3.Inside that method we have to create object by calling constructor.
4.we have to return the object reference.
5. In the caller side, we have to call static method , get the reference of the object.

"Factory Pattern is most popular pattern based static and private constructors"
package com.sapient.oo.object.state.constructors.priv;

public class Container {
    private Container() {
        System.out.println("Container is created");
    }

    //static
    public static Container getInstance() {
        Container container = new Container();
        return container;
    }

    public String getInfo() {
        return "Container";
    }
}

package com.sapient.oo.object.state.constructors.priv;

public class PrivateConstructorMain {
    public static void main(String[] args) {
        //Container container = new Container(); //calling constructor
        Container container = Container.getInstance();
        System.out.println(container.getInfo());
    }
}
.............................................................................................
				Hierachy
............................................................................................

Object relation ship.

One Object is not Object, Objects need to collbrate or connect each other.

There two types of object relationship

1.has-a / composition
2.is-a - inheritance

has- a:
 Object can have reference of the other objects.

Objects are made of up spare parts(components), Connecting all components making one big Component is called Compostion.


package com.sapient.oo.hasa;

public class Employee {
    private int id;
    private String name;
    private double salary;
    //address -has a
    private Address address;

    public Employee() {

    }

    public Employee(int id, String name, double salary, Address address) {
        this.id = id;
        this.name = name;
        this.salary = salary;
        this.address = address;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }
}
package com.sapient.oo.hasa;

public class Address {
    private String doorno;
    private String city;
    private String state;
    private String zipcode;

    public  Address(){

    }

    public Address(String doorno, String city, String state, String zipcode) {
        this.doorno = doorno;
        this.city = city;
        this.state = state;
        this.zipcode = zipcode;
    }

    public String getDoorno() {
        return doorno;
    }

    public void setDoorno(String doorno) {
        this.doorno = doorno;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    public String getZipcode() {
        return zipcode;
    }

    public void setZipcode(String zipcode) {
        this.zipcode = zipcode;
    }
}

package com.sapient.oo.hasa;

public class HasAMain {
    public static void main(String[] args) {
        Employee employee = new Employee();
        employee.setId(1);
        employee.setName("Subramanian");
        employee.setSalary(1000.89);
        Address address = new Address();
        address.setDoorno("10");
        address.setCity("Coimbatore");
        address.setState("Tamil Nadu");
        address.setZipcode("6000 001");
        //object binding or dependency injection
        employee.setAddress(address);

        //Access
        System.out.println("Id => " + employee.getId());
        System.out.println("Name => " + employee.getName());
        System.out.println("Salary => " + employee.getSalary());
        //address
        System.out.println("Address " + employee.getAddress());
        System.out.println("Door No =>" + employee.getAddress().getDoorno());
        System.out.println("City =>" + employee.getAddress().getCity());
        System.out.println("State =>" + employee.getAddress().getState());
        System.out.println("Zip code =>" + employee.getAddress().getZipcode());

        //with constructors
        Address address1 = new Address("11","Chennai","Tamil Nadu","6098823");
        Employee employee1 = new Employee(2,"John",7897.00,address1);

        System.out.println("Id => " + employee1.getId());
        System.out.println("Name => " + employee1.getName());
        System.out.println("Salary => " + employee1.getSalary());
        //address
        System.out.println("Address " + employee1.getAddress());
        System.out.println("Door No =>" + employee1.getAddress().getDoorno());
        System.out.println("City =>" + employee1.getAddress().getCity());
        System.out.println("State =>" + employee1.getAddress().getState());
        System.out.println("Zip code =>" + employee1.getAddress().getZipcode());

    }
}
............................................................................................
				 IS-A inheritance
............................................................................................

What is inheritance?
  Inheritance is nothing the way we re use  the code  across the different classes.
  Avoid code duplication.

Java supports single inheritance, means One class inherits the other class.

Terms:
1.Base class /parent Class/Super class
  The class is ready to share its code to other class
2.child class /dervied
   The class is ready to accept the code given other class.

In java inheritance happens during compile time only.

A.java
class A {
  //code
}
B.java
class B extends A {

}

After compilation

A.class
class A {
  //code
}
B.class
class B extends A {
 //code
}


=> inheritance means coping the base class code into dervied class during compile time.

What code can be copied from base class to child class?

all instance variables and methods having "public,default,protected" modifers

...........................................................................................
				inheritance implementation

1.class  -Regular class/concrete class
2.interfaces
3.abstract class


1.class  -Regular class/concrete class

public class Account {
    //instance variable
    protected int accountId = 100;

    //instance methods
    protected int deposit() {
        return 1000;
    }
}
public class SavingsAccount extends Account {

}
public class InheritanceMain {
    public static void main(String[] args) {
        SavingsAccount savingsAccount = new SavingsAccount();
        System.out.println(savingsAccount.accountId);
        System.out.println(savingsAccount.deposit());
    }
}

protected:
  
 protected  =  private + public

 protected variables can be accessed any where in the application but that class should be part of inheritance - public 
 protected variables can be accessed within class only, if the class is not part of inheritance.
..............................................................................................
 				default inheritance

=> Every class in java has default parent called Object which part of built in package called
   "java.lang". compiler automatically inherits the class during compile time.

Source code;

MyClass.java
 public class MyClass{

 }

public class YourClass extends MyClass{
}
After compilation

MyClass.class
 public class MyClass extends java.lang.Object{

 }

public class YourClass extends MyClass{
}
..............................................................................................
					Typing
.............................................................................................

 "Type of one variable can be converted into another type based on certain condition" -   Type Conversion

Types of type conversion:

1.implicit type conversion

 1.1.primitive type conversion
 1.2.reference type conversion

2.explicit type conversion
 2.1.primitive type conversion
 2.2.reference type conversion

1.implicit type conversion
 1.1.primitive type conversion

byte b=10;

byte b=int;

What is the type of b?
 byte
What is the type of 10?
 int

byte b=int;
 how int can be assinged to byte -  not possible

int size 4 byte
byte size 1 byte

1 = 4 => overflow


 byte b = 10;
 System.out.println(b);
 
 here 10(int) is converted into byte automatically - Implicit type conversion.
byte range - 1



byte b2 = 128;
System.out.println(b2);
you will get compil time error, 128 is bigger size than byte, so compiler cant cast automatically
Still i want it?
    "Explicit type conversion" 

Syntax

  targetType variable =(targetType) value(sourceType)
  
byte b2 = (byte) 128; //int is converted into byte
System.out.println(b2);
..............................................................................................
				 float and double
..............................................................................................

  float f =10.5; =>compile time error

 f type is float
 10.5 type is double
 double cant be assinged to float
  
Type conversion:


1.Explicit conversion
float f =(float)10.5;

2.implicit conversion by adding suffix "f or F"
float f1 = 10.5f;
.............................................................................................
				int,long

long l =10;
long =int

long l = 10L;
long =long
............................................................................................
				 char and int

Every character is int.

    char a = 'a';
    char c = 100;
    System.out.println(a + " " + c);
...........................................................................................
Implicit means : small to big 
Explicit means : big to small
.............................................................................................
				Wrapper classes
.............................................................................................

In Java , all Primitives are represented as Objects called Wrapper objects

int -------> java.lang.Integer
short ----->java.lang.Short
byte-------->java.lang.Byte
long-------->java.lang.Long
float ------>java.lang.Float
double------->java.lang.Double
char-------->java.lang.Char

Object creation in Wrapperclasses and how to assign values.

Pattern 1: very old pattern
Integer ins = new Integer(100);
System.out.println(ins.intValue());

Pattern 2: recommended

Integer ins1 = 100;
System.out.println(ins1.intValue());

Integer          ins1 =         100;
 |                 |             |
Object type   referencevariable primitive

Here we assign primitve type into object type, it is not possible default.

 "Here type conversion is happening"  -  Boxing

What is Boxing?
   Converting primitives into reference type called "Boxing"

What is UnBoxing?
    int b = ins1;
    System.out.println(b);
  Converting reference type into primitive type called "Unboxing"

Auto boxing:
  Boxing and unboxing happens automatically which we call "auto boxing".
..............................................................................................
			 Strings and type conversion
.............................................................................................

Strings are immutable object, collection of unicode characters

What is immutable object?
 immutablity means once the object is created can't be changed.

mutability means if object state  is modified by using methods, the object memory location is updated again and again.

immutablity means if object state is modified by using methods, for every change, new Object is created.

String Object Creations

String str = new String("hello") // this is not recommended

String str = "Hello";
System.out.println(str);
.............................................................................................
			  How to get Memory address in java
.............................................................................................

In General memory address we cant get in java. because java does not support pointers.

Java exposes some pattern through which you can get address of object but which is not real address(fake address) assigned by jvm.
 
hashCode:
  It is unique identification give by the jvm to every object is created inside heap.
  hashcode is method from the java.lang.Object.

 package com.sapient.oo.typing;

public class StringsDemo {
    public static void main(String[] args) {
        String str = "Hello";
        System.out.println(str + " its hashcode " + str.hashCode());
        //do some state changes
        String upperStr = str.toUpperCase();
        System.out.println(upperStr + " its hashcode " + upperStr.hashCode());

    }
}
output:
Hello its hashcode 69609650
HELLO its hashcode 68624562
.............................................................................................. 			String Buffer and String Builder
..............................................................................................

Mutable representation of String if you want, You can use StringBuffer or StringBuilder.

  StringBuffer buffer = new StringBuffer();
        System.out.println("Inital Buffer hash code " + buffer.hashCode());
        //modify the buffer
        StringBuffer newBuffer= buffer.append("hello");
        System.out.println("After Modification Buffer hash code " + newBuffer.hashCode());

Inital Buffer hash code 99347477
After Modification Buffer hash code 99347477
.............................................................................................
			 String to Integer Type conversion
.............................................................................................

package com.sapient.oo.typing;

public class StringToNumberConversion {
    public static void main(String[] args) {
        String n1 = "10";
        String n2 = "20";
        //Type Conversion : WrapperTypeParseMethod
        int c = Integer.parseInt(n1) * Integer.parseInt(n2);
        System.out.println(c);

    }
}
.............................................................................................
				Typing and Inheritance
............................................................................................

Program to Super Type:
.....................

The type of reference variable can be

=>concrete type
=>super type

Animal.java

public class Animal {
    public void eat(){
        System.out.println("Animal is eating");
    }
}

Dog.java
public class Dog extends Animal {
  
}

:concrete type
Dog dog = new Dog();
dog.eat();

Program to super type: the type of variable can be super/parent type
//program to super type
Animal dog1 = new Dog();
dog1.eat();
..............................................................................................
			 How eat method is called?


source code :

Animal.java

public class Animal {
    public void eat(){
        System.out.println("Animal is eating");
    }
}

Dog.java
public class Dog extends Animal { 

}
Here eat method is not available in the dervied class,  

dog.eat(); how eat method  is available for accessing using reference variable


Animal.class

public class Animal {
    public void eat(){
        System.out.println("Animal is eating");
    }
}

Dog.class
public class Dog extends Animal { 
   public void eat(){
        super.eat()
   }
}
dog.eat(); 

super keyword:
..............

=>super is pointer (reference variable like this).
=>this points the current object where as super points parent object
=>super keyword can be used to access  parent class methods,variables
..........................................................................................
			 What if i provide my own eat method in the child class

public class Animal {
    public void eat(){
        System.out.println("Animal is eating");
    }
}
public class Dog extends Animal {
    public void eat(){
        System.out.println("Dog eats");
    }
}
dog.eat();

if you define the method from the base class to child class : "Overriding"

After overriding what i want to call base class eat also?
 you can use super keyword explicitly.

public class Dog extends Animal {
    public void eat(){
        super.eat();
        System.out.println("Dog eats");
    }
}
.............................................................................................
				Program to Super type advanced.


public class Animal {
    void eat(){
        System.out.println("Animal is eating");
    }
}
public class Dog extends Animal {
    public void eat(){
        super.eat();
        System.out.println("Dog eats");
    }
}

Animal dog = new Dog();
dog.eat();



public class Dog extends Animal {
    @Override
    public void eat() {
        super.eat();
        System.out.println("Dog eats");
    }

    //extra method
    public void bark() {
        System.out.println("dog is barking");
    }
}

 Animal dog = new Dog();
 dog.eat();
  //call bark method
  dog.bark();
Cannot resolve method 'bark' in 'Animal'

 Here "dog" reference variable, type is animal type, Object is Dog.

Formula:
        "Java always binds the method expression based on Type only during compile time"
        "During compile time compiler always check left side(type) whether the method belongs           that type or not"
         Animal dog = new Dog();
         dog.eat();
	 
         "During runtime, jvm always looks Object , that means right Side"
          dog.eat()
..............................................................................................
     dog.bark() - since the bark method is not available in the Animal type, we cant compile.

How to call bark with help of Parent Type?
   "Type Conversion".

We have to convert Animal to Dog.

According to inheritance, Parent Type is big one, child Type is small one.

int a =900
byte b =(byte)a; //Explicit cast is required when you cast big to small , 

Converting reference types  called as "Down Cast".
Animal dog = new Dog();
dog.eat();
//call bark method
Dog tmpDog= (Dog)dog; // cast Animal to Dog
tmpDog.bark();
..............................................................................................
				 What can be super type
->super type can be class,interface,abstract class
->super type of  a variable can be immediate parent Dog...to Animal
->super type of a variable can be "java.lang.Object"

   //Object as Super type
        Object myDog = new Dog();
        Animal animal = (Animal) myDog;
        animal.eat();
        Dog tmpDog2 = (Dog) myDog;
        tmpDog2.bark();


Polymorphism:

   Polymorphism is the ability of an object to take on many forms. The most common use of polymorphism in OOP occurs when a parent class reference is used to refer to a child class object. 
 
Types of Polymorphism

1.Compile time polymorphism/Early binding:

  During compile time , the compiler binds/fixes the signature of methods with reference variable based on "Type".
  Compile time polymorphism happens with object not in the inheritance tree.

How to implment Compile time polymorphism?

Overloading:
  The reference variable binds the methods based on method signature.

=>method name should be same
=>method args should be different types or no of args
=>method return type need not match.

Types of overloading:

1.method overloading
2.constructor overloading
3.operator overloading
  java does not support operator overloading except + operator.

    
Method overloading:
package com.sapient.oo.typing.poly.compile;

public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public int add(int a, int b, int c) {
        return a + b + c;
    }

    public double add(double a, double b) {
        return a + b;
    }
}
package com.sapient.oo.typing.poly.compile;

public class OverloadingMain {
    public static void main(String[] args) {
        Calculator calculator = new Calculator();
        System.out.println(calculator.add(10, 10));
        System.out.println(calculator.add(1, 3, 4));
        System.out.println(calculator.add(10.4, 19.8));
    }
}

constructor overloading:
=>constructor name is same
=>constructor args are different type or no parameters 


package com.sapient.oo.typing.poly.compile;

public class Employee {
    private int id;
    private String name;

    public Employee() {

    }

    public Employee(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public Employee(int id) {
        this.id = id;
    }

    public Employee(String name) {
        this.name = name;
    }
}
Employee emp = new Employee();
Employee emp1 = new Employee(1);
Employee emp2 = new Employee("ff");
Employee emp3 = new Employee(1, "ddd");

.............................................................................................

Runtime Polymorphism: Overriding:
   It is all about method invocation based on object.

Rules:
Methods of child and parent class must have the same name.
Methods of child and parent class must have the same parameter.
Access modifer in the parent class
   public 
   public
   protected
   public 
private methods cant be overriden
final methods cant be overriden
Return type can be super or child type.
..............................................................................................
				 interfaces
............................................................................................

interface is looks like class, it defines only method signature.
The method we declare inside interface is called abstract methods
interface is used for
  ->Act as parent class having common behaviour and to be implemented across the classes.
  ->Can hide  multiple implemenation under single Type -  has-a relationship

interface as base class:
public interface Flyable {
    //declare methods
    public abstract void fly();
}  

Simple syntax :
=>by default all methods inside  interface is public abstract, so we dont need to use public and abstract keywords
 
public interface Flyable {
    //declare methods
    void fly();
}
 
public class Crow implements Flyable {
    @Override
    public void fly() {
        System.out.println("Crow is flying");
    }
}
Crow crow = new Crow();
crow.fly();
        //program to super type
        Flyable crow1 = new Crow();
        crow1.fly();
        Crow tmpCrow = (Crow) crow1;
        tmpCrow.buildNest();

............................................................................................
			     interface vs class

Which one , when to use?

                   "Classes are used for sharing code with in family of object tree"

Human family:
  class Human { 
     method
  }
  class Male extends Human {}
  class FeMale extends Human {}
  
	"interfaces are used for sharing code across the different family of object tree"
		

public interface Flyable {
    //declare methods
  //  public abstract void fly();
    void fly();
}
package com.sapient.oo.typing.interfaces;

public class Crow implements Flyable {
    @Override
    public void fly() {
        System.out.println("Crow is flying");
    }
    public void buildNest(){
        System.out.println("Nest");
    }
}
package com.sapient.oo.typing.interfaces;

public class AirPlan implements Flyable{
    @Override
    public void fly() {
        System.out.println("Airplan is flying");
    }
}
..............................................................................................

Rules:

1.interfaces can inherit other interfaces

public interface Adder {
    void add(int a, int b);
}
public interface Substractor {
    void substract(int a, int b);
}
public interface Calculator extends Adder, Substractor {

}
public class Math implements Calculator{
    @Override
    public void add(int a, int b) {
        System.out.println(a+b);
    }

    @Override
    public void substract(int a, int b) {
        System.out.println(a-b);

    }
}
        
Calculator calculator = new Math();
calculator.add(100,100);
calculator.substract(20,10);


2.1.interfaces cant implement other  interfaces

3.interface cant have private and final methods

4.interface cant have instance variables, but can have static variables and must have initalized

public interface Calculator extends Adder, Substractor {
  static int a=0;
}
..............................................................................................
				 Abstract classes
..............................................................................................

Class with abstract method and non method methods

Abstract class = interface + class

Abstract class is used to share code in the same family but some behaviours are decided later.

Abstract class must have abstract methods, to be overriden by child class.

Abstract class can extend interfaces


public abstract class Animal {
    abstract public void eat();

    public String saveAnimals() {
        return "Save Animals from the Hunter";
    }
}
package com.sapient.oo.typing.abstractcls;

public class Dog extends Animal{
    @Override
    public void eat() {
        System.out.println("Dog eats");
    }
}

package com.sapient.oo.typing.abstractcls;

public class Tiger extends Animal {
    @Override
    public void eat() {
        System.out.println("Tiger eats");
    }
}


public class AbstractClassMain {
    public static void main(String[] args) {
        Animal animal = null;
        animal = new Dog();
        animal.eat();
        System.out.println(animal.saveAnimals());

        animal = new Tiger();
        animal.eat();
        System.out.println(animal.saveAnimals());

    }
}
..............................................................................................
                      null, non access modifers -(final,abstract)
..............................................................................................

final:

Variables:

final variables cant be changed once it is initalized- constant
final variables must be intialized

public class Container {
    final int a;
}
//errror
public class Container {
    final int a=0;
}
Container container = new Container();
System.out.println(container.a);
container.a =100; //error

instance variables should not be declared final - coding standard

static variables are declared final

public class Container {
    public static final  double PI = 3.14;
    final int a = 0;
}
.............................................................................................

local variables and final keyword:
..................................
   public void getValue(){
        final  int b =10;
        //b=90;
        System.out.println(b);
    }
...........................................................................................
				final methods
............................................................................................


final methods cant be overriden but we can access outside class if it is public 

   public final void setValue() {
        System.out.println("value is set");
    }

............................................................................................
			   final class

we can declare class as final, if you do so you cant inherit class.

All wrapper classes and string class are final classes.

package com.sapient.oo.finalkeyword;

public final class MyString {
    public void setValue(){
        System.out.println("final class");
    }
}
public class NewString extends MyString{
}
 //error.
.............................................................................................
					null
..............................................................................................

What is null?
 null is value(Internally null itself is Object), which indicates the reference variable does not point valid object location.

package com.sapient.oo.nullvalue;

public class NullMain {
    public static void main(String[] args) {
        //here employee variable has valid memory address
        Employee employee = new Employee();

        //employee1 variable is not pointing any valid object location
        Employee employee1 = null;
        //if you try to access any property on "Employee" type and its object location not there so it will throw error
        //runtime error.
        employee1.setId(10);

    }
}
.............................................................................................
				instance of Operator
.............................................................................................
The java instanceof operator is used to test whether the object is an instance of the specified type (class or subclass or interface).


package com.sapient.oo.instanceofoperator;

/**
 * if interface has no any method, that interface is called "marker" interface
 */
public interface MyInterface {
}

package com.sapient.oo.instanceofoperator;

public class Employee implements MyInterface {
}
package com.sapient.oo.instanceofoperator;

public class InstanceOfMain {
    public static void main(String[] args) {
        Employee employee = new Employee();
        System.out.println(employee instanceof  Employee);
        System.out.println(employee instanceof  Object);
        System.out.println(employee instanceof  MyInterface);
    }
}
............................................................................................
			 java.lang.Object

Methods:

1.toString()
   It returns string representation of Object.
if you dont override this method in any class java.lang.Object toString is method.

by default toString method returns value like below

com.sapient.oo.objectclass.Greeting@1d251891


Overriding toString method and get meaningfull output
package com.sapient.oo.objectclass;

public class Greeting {

    private String message;
    private String name;

    public Greeting(){

    }

    public Greeting(String message, String name) {
        this.message = message;
        this.name = name;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    //Override to String method

    @Override
    public String toString() {
        return "Greeting{" +
                "message='" + message + '\'' +
                ", name='" + name + '\'' +
                '}';
    }
}
public class ObjectMain {
    public static void main(String[] args) {
        Greeting greeting = new Greeting("Hello","Subramanian");
        //System.out.println(greeting.getMessage() + " " +greeting.getName());
        //toString
        System.out.println(greeting.toString());
        System.out.println(greeting); //here toString is called automatically
    }
}
..............................................................................................
				hashcode()


hashcode method returns an integer which represents hash value of the java object.
System.out.println(greeting.hashCode());

Can i override hashcode?

Yes
package com.sapient.oo.objectclass;

import java.util.Objects;

public class Greeting {

    private String message;
    private String name;

    public Greeting(){

    }

    public Greeting(String message, String name) {
        this.message = message;
        this.name = name;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    //Override to String method

    @Override
    public String toString() {
        return "Greeting{" +
                "message='" + message + '\'' +
                ", name='" + name + '\'' +
                '}';
    }
    //override hashcode
//    @Override
//    public int hashCode() {
//        return 100;
//    }
    @Override
    public int hashCode() {
        return Objects.hash(message,name);
    }
}
      package com.sapient.oo.objectclass;

public class ObjectMain {
    public static void main(String[] args) {
        Greeting greeting = new Greeting("Hello","Subramanian");
        System.out.println(greeting.hashCode());
    }
}
..............................................................................................
				equals Method
..............................................................................................

To test equality of objects.

In order to test equality we have == operator and also we have equals Method.

== Operator:
...........

With Primitive Values to test two different variables having same value or not.
   int a = 10;
        int b = 10;
        if (a == b) {
            System.out.println("Equal");
        } else {
            System.out.println("Not equal");
        }

With Reference types and equal operator

        Greeting greeting1 = new Greeting("Hello", "Subramanian");
        Greeting greeting2 = new Greeting("Hai", "Ram");

        if (greeting1 == greeting2) {
            System.out.println("Greetings are equal");
        } else {
            System.out.println("Greetings are not equal");
        }

Here we are comparing not objects but object locations.

 "Whether two reference variables points the same object(one location) or not"

Here no, so it will give "Greetings are not equal".
 //Equal condition with single object
        Greeting greeting3 = new Greeting();
        Greeting greeting4 = greeting3;
        if (greeting3 == greeting4) {
            System.out.println("Greetings are equal");
        } else {
            System.out.println("Greetings are not equal");
        }
.............................................................................................
				equals method
.............................................................................................

=>This method is used to compare objects only not its memory location.
   
  If i create two objects having content are same
  eg : Two Employee objects having same employeeid.



package com.sapient.oo.objectclass;

import java.util.Objects;

public class Greeting {

    private int id;
    private String message;
    private String name;

    public Greeting(){

    }

    public Greeting(int id,String message, String name) {
        this.id =id;
        this.message = message;
        this.name = name;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
    //Override to String method

    @Override
    public String toString() {
        return "Greeting{" +
                "message='" + message + '\'' +
                ", name='" + name + '\'' +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Greeting)) return false;
        Greeting greeting = (Greeting) o;
        return id == greeting.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

package com.sapient.oo.objectclass;
public class EqualsMethodMain {
    public static void main(String[] args) {
        Greeting greeting1 = new Greeting(1,"Hello","Subramanian");
        Greeting greeting2 = new Greeting(6,"Hello","Subramanian");
        System.out.println("Greeting 1 Hashcode " + greeting1.hashCode());
        System.out.println("Greeting 2 Hashcode " + greeting2.hashCode());

        //by default equals method test object reference equality using == operator
        System.out.println(greeting1.equals(greeting2) ? "Objects are equal" : "Objects are not equal");

    }
}
.............................................................................................
				   Exception handling
.............................................................................................
In software systems errors are common, which is unavoidable.

Types of errors:

1.Program errors
   ->compile time errors
      Errors are identified during development time
    compile time errors are not danger,because can be fixed

   ->Runtime errors 
      Errors are identified during runtime of application.
      Errors are danager which stops the application to run.
      This is unavoiable
      This has to be handled properly    
        Handling runtime errors are called "exception handling"

2.System errors
    Due to system mal function like , sudden machine restarts,disk failure,io devices failures,memory overflow.
    We cant fix / handle this via software

How to handle Exception(Application Runtime errors)?

java provides a mechanism to handle errors sommothly.

if you dont write error handling code, java will do automatically.
.............................................................................................
				Handling exceptions


java provides keywords to handle exception

1.try...catch..finally
2.throw 
3.throws 

Exception is Object oriented, java provides a base class to abstract exception.

				java.lang.Throwable

The Throwable class is the superclass of all errors and exceptions in the Java language
Only objects that are instances of this class (or one of its subclasses) are thrown by the Java Virtual Machine or can be thrown by the Java throw statement


				java.lang.Throwable
					 |
		---------------------------------------------------------
                |							|
             java.lang.Error                                     java.lang.Exception




Error:
   An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.
Most such errors are abnormal conditions. The ThreadDeath error, though a "normal" condition, is also a subclass of Error because most applications should not try to catch it.

Exception:
  The class Exception and its subclasses are a form of Throwable that indicates conditions that a reasonable application might want to catch.

............................................................................................
				 Types of Exception
............................................................................................

1.UnChecked Exception

    Exceptions need not be handled by write special code(try...catch).
    what if exceptions occured, JVM will handle auotmatically.

Eg;
   NullPointerException
       Exception(error) , is thrown by the jvm incase if you access object properties , if object does not exit.

  static void checkNullException() {
        String str = null;
        System.out.println(str.length());
    }
  NumberFormatException
     Incase string to number conversion, if it fails
    static  void checkNumberFormate(){
        String str = "$10";
        int a = Integer.parseInt(str);
        System.out.println(a);
    }
etc...

How to identify the unchecked Exception?
			
 if any exception inherits "java.lang.RuntimeException" or any Exception subclass of RuntimeException are called "UnChecked Exception"


How to handle Unchecked Exception?
  Handling means reporting errors.

try....catch block
static void handleException() {
        try {
            //your application
            String str = "$10";
            int a = Integer.parseInt(str);
            System.out.println(a);
        } catch (NumberFormatException es) {
            //reporting block
            System.out.println(es.getMessage());
        }

    }

2.Checked Exception
    Exceptions need to be handled by writing code using try...catch or throws.
    The code which throws CheckedException, without handling using try...catch or throws , we cant compile the code.

CheckedException is used in many java apis

1.java.io apis
2.java.sql apis
3.java.net apis
etc.....
..............................................................................................
				Custom Exception /Biz Exception
.............................................................................................

Custom Exceptions /Biz Exceptions can be created based on our application code.

Custom Exception can be checked or unchecked Exception.
............................................................................................
				UnChecked Custom Exception
.............................................................................................

Steps:

1.Write a class extends "java.lang.RuntimeException".

2.add Constructors 

public class BalanceNotFoundException extends RuntimeException {
    public BalanceNotFoundException() {
        super(); // calling super class constructor
    }
    public BalanceNotFoundException(String errorMessage) {
        super(errorMessage); // calling super class constructor
    }
}

3.write biz class , and methods ,simulate exception.

we have to create Exception Object, we have to throw it

package com.sapient.exceptions.custom.uncheck;

public class AccountService {
    private double balance = 1000.00;

    public double witdraw(double amt) {
        if (balance < amt) {
            //error : you are throwing where this method is called.
            throw new BalanceNotFoundException("Balance Not Found " + "balace=>" + balance + "amt to be withdrawn =>" + amt);
        }
        return balance - amt; //balance
    }
}

4.call biz method , handle exception 

package com.sapient.exceptions.custom.uncheck;

public class Main {
    public static void main(String[] args) {
        AccountService accountService = new AccountService();
        double response = 0.0;
        response = accountService.witdraw(100);
        System.out.println("Response is " + response);
        //without try catch code will be compiled...
//        response = accountService.witdraw(3000);
//        System.out.println("Response is " + response);
        //with try ...catch
        try {
            response = accountService.witdraw(3000);
            System.out.println("Response is " + response);
        } catch (BalanceNotFoundException es) {
            System.out.println(es.getMessage());
        }

    }
}
.............................................................................................
				Checked Custom Exception
.............................................................................................

Steps

1.Write a class extends "java.lang.Exception".


public class BalanceNotFoundException extends Exception {
    public BalanceNotFoundException() {
        super(); // calling super class constructor
    }
    public BalanceNotFoundException(String errorMessage) {
        super(errorMessage); // calling super class constructor
    }
}

2.write biz class , and methods ,simulate exception.
public class AccountService {
    private double balance = 1000.00;

    public double witdraw(double amt) {
        if (balance < amt) {
            //error : you are throwing where this method is called.
            throw new BalanceNotFoundException("Balance Not Found " + "balace=>" + balance + "amt to be withdrawn =>" + amt);
        }
        return balance - amt; //balance
    }
}

You will get compile time error:
 Unhandled exception: com.sapient.exceptions.custom.checked.BalanceNotFoundException

We have not called exception, but why we are getting this error. we need to bind CheckedException with this method.

"throws" -  keyword used to bind Checked Exception with method.

public class AccountService {
    private double balance = 1000.00;

    public double witdraw(double amt) throws BalanceNotFoundException {
        if (balance < amt) {
            //error : you are throwing where this method is called.
            throw new BalanceNotFoundException("Balance Not Found " + "balace=>" + balance + "amt to be withdrawn =>" + amt);
        }
        return balance - amt; //balance
    }
}

3. caller side
public class Main {
    public static void main(String[] args) {
        AccountService accountService = new AccountService();
        double response = 0.0;
        response = accountService.witdraw(100);
        System.out.println("Response is " + response);
    }
}
here compiler will throw error
Unhandled exception: com.sapient.exceptions.custom.checked.BalanceNotFoundException

Here checkedException forces to handle it

using try ...catch...
      try {
            response = accountService.witdraw(4000);
            System.out.println("Response is " + response);
        } catch (BalanceNotFoundException e) {
            System.out.println(e.getMessage());
        }

Sometimes , we are interested to use try...catch, how to compile the code?

yes we can , escaping handling exception using try...catch.

"using throws" keyword
package com.sapient.exceptions.custom.checked;

public class Main {
    public static void main(String[] args) throws BalanceNotFoundException {
        AccountService accountService = new AccountService();
        double response = 0.0;
        response = accountService.witdraw(4000);
        System.out.println("Response is " + response);

//        try {
//            response = accountService.witdraw(4000);
//            System.out.println("Response is " + response);
//        } catch (BalanceNotFoundException e) {
//            System.out.println(e.getMessage());
//        }
    }
}
.............................................................................................
			 finally keyword


finally is used for writing some clean up activties such as file closing operations,like so
finally is called whether exception is thrown are not.

package com.sapient.exceptions.custom.checked;

public class Main {
    public static void main(String[] args) { // throws BalanceNotFoundException {
        AccountService accountService = new AccountService();
        double response = 0.0;
        try {
            response = accountService.witdraw(1000);
            System.out.println("Response is " + response);
        } catch (BalanceNotFoundException e) {
            System.out.println(e.getMessage());
        } finally {
            System.out.println("called");
        }
    }
}
............................................................................................
				multi catch

We can have mulitple catch Statement. Each catch statement is used to identifiy specific errors.


package com.sapient.exceptions;

public class MulitCatch {

    public static void checkMultiCatch() {
        try {
            String str = "10";
            System.out.println(Integer.parseInt(str));
            String str2 = "";
            System.out.println(str2.toUpperCase());
            int a = 10;
            int res = a / 0;
            System.out.println(res);

        } catch (NumberFormatException es) {
            System.out.println("Number error");
        } catch (NullPointerException es) {
            System.out.println("Null Error");
        } catch (RuntimeException es) {
            System.out.println(es.getMessage());
        } catch (Exception es) {
            System.out.println(es.getMessage());
        } catch (Throwable es) {
            System.out.println(es.getMessage());
        }
    }

    public static void main(String[] args) {
        checkMultiCatch();
    }
}
..............................................................................................	
			      IO - Input and Output in java
.............................................................................................

Java supports IO operations via java.io and javax.nio package.

Java can read and write bytes/characters from the various sources

Sources:
 - Keyboard
 - File
 - Network sockets
Java reads or writes data in the two forms

1.byte 
2.char

Java uses a concept called "stream"

Stream is nothing but "flow of data" 

Types of Streams:

1.Byte Streams
  handle I/O of raw binary data.
2.Character Streams 
   handle I/O of character data, automatically handling translation to and from the local character set.
3.Buffered Streams
  optimize input and output by reducing the number of calls to the native API.
4.Scanning and Formatting 
    allows a program to read and write formatted text.
5.I/O from the Command Line 
  describes the Standard Streams and the Console object.
6.Data Streams 
   handle binary I/O of primitive data type and String values.
7.Object Streams 
   handle binary I/O of objects.


Byte Streams
   Programs use byte streams to perform input and output of 8-bit bytes. All byte stream classes are descended from InputStream and OutputStream.

  There are many byte stream classes. To demonstrate how byte streams work, we'll focus on the file I/O byte streams, FileInputStream and FileOutputStream. Other kinds of byte streams are used in much the same way; they differ mainly in the way they are constructed.

package com.sapient.io.streams;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class ReadFileUsingStream {
    public static void main(String[] args) {
        System.out.println("File input stream");
        String filename = "E:\\session\\sapient\\Java-QA\\javaapps\\src\\main\\resources\\hello.txt";
        try {
            FileInputStream fileInputStream = new FileInputStream(filename);
//            int singleByte = fileInputStream.read();
//            System.out.println("data in bytes => " + singleByte);
            int data;
            while ((data = fileInputStream.read()) != -1) {
              //  System.out.println(data + "  " + (char) data);
                System.out.print((char) data);
            }

        } catch (FileNotFoundException e) {
            System.out.println("file Not found" + e);
        } catch (IOException e) {
            System.out.println("IO Exception" + e.getMessage());
        }
    }
}

How to write data into file?
package com.sapient.io.streams;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class WriteIntoFileOutputStream {
    public static void main(String[] args) {
        System.out.println("File input stream");
        String filename = "E:\\session\\sapient\\Java-QA\\javaapps\\src\\main\\resources\\hello.txt";
        try {
            FileInputStream fileInputStream = new FileInputStream(filename);
            FileOutputStream fileOutputStream = new FileOutputStream("hello_copy.txt", true);
            int data;
            while ((data = fileInputStream.read()) != -1) {
                //System.out.print((char) data);
                fileOutputStream.write(data);
            }

        } catch (FileNotFoundException e) {
            System.out.println("file Not found" + e);
        } catch (IOException e) {
            System.out.println("IO Exception" + e.getMessage());
        }
    }
}
..............................................................................................
			 Character Streams 
Handle I/O of character data, automatically handling translation to and from the local.
Character takes care of converting bytes into characters automatically.

package com.sapient.io.streams.chars;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CharacterReaderAndWriter {
    public static void main(String[] args) throws IOException {
        String filename = "hello_copy.txt";
        FileReader fileReader = null;
        FileWriter fileWriter = null;
        try {
            fileReader = new FileReader(filename);
            fileWriter = new FileWriter("newFile.txt", true);
            int data;
            while ((data = fileReader.read()) != -1) {
                //System.out.print((char) data);
                fileWriter.write(data);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } finally {
            //every file must be closed
            fileReader.close();
            fileWriter.close();
        }
    }
}
..............................................................................................
                                    Buffered Streams

Buffered Streams are very usefull for increasing performance , avoid data loss in case source stream(upStream) is faster than down Stream.

Buffered Streams create temp buffer between up and down stream.

inputStream = new BufferedReader(new FileReader("xanadu.txt"));
inputStream = new BufferedInputStream()

outputStream = new BufferedWriter(new FileWriter("characteroutput.txt"));
outputStream = new BufferedOutputStream()

package com.sapient.io.streams.buffered;

import java.io.*;

public class BufferedStreamsMain {
    public static void main(String[] args) throws IOException {
        String filename = "hello_copy.txt";
        FileReader fileReader = null;
        FileWriter fileWriter = null;
        BufferedReader bufferedReader = new BufferedReader(new FileReader(filename));
        
        try {
            fileWriter = new FileWriter("newFile.txt", true);
            int data;
            while ((data = bufferedReader.read()) != -1) {
                //System.out.print((char) data);
                fileWriter.write(data);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } finally {
            //every file must be closed
            bufferedReader.close();
            fileWriter.close();
        }
    }
}
.............................................................................................
				 Scanner
.............................................................................................
Objects of type Scanner are useful for breaking down formatted input into tokens and translating individual tokens according to their data type.

package com.sapient.io.scannerio;

import java.util.Scanner;

public class ScannerMain {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter Your name");
        String name = scanner.nextLine();
        System.out.println("Your name is " + name);
    }
}
.............................................................................................
                 How to write Object into disk and how to read Object from the disk
.............................................................................................

Java supports various data io.

If you want to send primitive data types values to file system via "Data Streams"

if you want to persist Objects into file system via "Object Streams".

Moving Object into file system and read Object from the system which is called as "Serialization".

Any Java object can be serialized, if want to serialize you have to implement the steps


1.declare class and implement Serializable interface

package com.sapient.io.serialization;

import java.io.Serializable;

public class Customer implements Serializable {
    private int id;
    private String name;
    private String city;

    public Customer() {

    }

    public Customer(int id, String name, String city) {
        this.id = id;
        this.name = name;
        this.city = city;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }
}

   
package com.sapient.io.serialization;

import java.io.*;

public class SaveObjectMain {
    public static void saveObject() throws IOException {
        Customer customer = new Customer(1, "Subramanian", "Coimbatore");
        String filename = "customer.ser";
        FileOutputStream fileOutputStream = null;
        ObjectOutputStream objectOutputStream = null;
        try {
            fileOutputStream = new FileOutputStream(filename);
            objectOutputStream = new ObjectOutputStream(fileOutputStream);
            //write objects into stream
            objectOutputStream.writeObject(customer);
            objectOutputStream.flush();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            objectOutputStream.close();
            fileOutputStream.close();
        }

    }

    public static void readObject() {
        try {
            //Creating stream to read the object
            ObjectInputStream in = new ObjectInputStream(new FileInputStream("customer.ser"));
            Customer customer = (Customer) in.readObject();
            //printing the data of the serialized object
            System.out.println("From the disk : " + customer);
            //closing the stream
            in.close();
        } catch (Exception e) {
            System.out.println(e);
        }
    }


    public static void main(String[] args) throws IOException {
        saveObject();
        readObject();
    }
}
..............................................................................................
				 Can we read other files

Word document
Excel Sheet
Pdf files

Yes we can ,java.io package does not have any special apis to read theses file formats?

There are third party libs are available to read and write .

Apache POI - the Java API for Microsoft Documents

How to read data from the excel file?
package com.sapient.io.execel;

import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Iterator;

public class ReadFromExcelFile {
    public static void main(String[] args) {
        try {
            FileInputStream file = new FileInputStream(new File("mydoc.xlsx"));
            XSSFWorkbook workbook = new XSSFWorkbook(file);
            //Get first/desired sheet from the workbook
            XSSFSheet sheet = workbook.getSheetAt(0);
            System.out.println("Sheet Name : " + sheet.getSheetName());
            Iterator<Row> rowIterator = sheet.iterator();
            while (rowIterator.hasNext()) {
                Row row = rowIterator.next();
                //For each row, iterate through all the columns
                Iterator<Cell> cellIterator = row.cellIterator();

                while (cellIterator.hasNext()) {
                    Cell cell = cellIterator.next();
                    //Check the cell type and format accordingly
                    switch (cell.getCellType()) {
                        case Cell.CELL_TYPE_NUMERIC:
                            System.out.println(cell.getNumericCellValue() + "\t");
                            break;
                        case Cell.CELL_TYPE_STRING:
                            System.out.print(cell.getStringCellValue() + "\t");
                            break;
                    }
                }
                System.out.print("");
            }
            file.close();

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
..............................................................................................
				 Data Structures
.............................................................................................

1.Array :
 
In java array is Object.
Java arrays are fixed in size
Java arrays store only one type of data.

package com.sapient.ds.arrays;

public class ArrayDemo {
    public static void main(String[] args) {
        int[] list = {1, 2, 3, 4, 5, 6, 7};
        System.out.println("length" + list.length);
        //iterate
        for (int i = 0; i < list.length; i++) {
            System.out.println(list[i]);
        }
        //Array of employees
        Employee[] employees = {
                new Employee(1, "A"),
                new Employee(2, "B")
        };
        for (int i = 0; i < employees.length; i++) {
            System.out.println(employees[i]);
        }
    }
}
..............................................................................................

Sorting:
package com.sapient.ds.arrays;

import java.util.Arrays;

public class ArrayProcessing {
    public static void main(String[] args) {
        int[] list = {8, 3, 1, 2, 0, 4, 5};
        System.out.println("Before Sorting");
        for (int i = 0; i < list.length; i++) {
            System.out.println(list[i]);
        }
        Arrays.sort(list);
        System.out.println("After Sorting");
        for (int i = 0; i < list.length; i++) {
            System.out.println(list[i]);
        }
        Employee[] employees = {
                new Employee(2, "A"),
                new Employee(3, "B")
        };
        System.out.println("Before Sorting -Employees");

        for (int i = 0; i < employees.length; i++) {
            System.out.println(employees[i]);
        }
        Arrays.sort(employees);
        System.out.println("After Sorting -Employees");
        for (int i = 0; i < employees.length; i++) {
            System.out.println(employees[i]);
        }
    }
}

Here the above example throws Error because , java does not know how to sort Employees.

Like equals method, we need to tell java that on what field we sort that means on id, or name or salary.

How to write sort algorthim for objects?

1.by implementing java.lang.Comparable interface

2.by write a separate sorting class which implements java.util.Comparator.


package com.sapient.ds.arrays;


public class Employee implements Comparable<Employee> {
    private int id;
    private String name;

    public Employee() {

    }

    public Employee(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int compare(int x, int y) {
        return (x < y) ? -1 : ((x == y) ? 0 : 1);
    }

    @Override
    public int compareTo(Employee employee) {
        return compare(this.id, employee.getId());
    }
}
package com.sapient.ds.arrays;

import java.util.Arrays;

public class ArrayProcessing {
    public static void main(String[] args) {
        int[] list = {8, 3, 1, 2, 0, 4, 5};
        System.out.println("Before Sorting");
        for (int i = 0; i < list.length; i++) {
            System.out.println(list[i]);
        }
        Arrays.sort(list);
        System.out.println("After Sorting");
        for (int i = 0; i < list.length; i++) {
            System.out.println(list[i]);
        }
        Employee[] employees = {
                new Employee(4, "A"),
                new Employee(1, "B")
        };
        System.out.println("Before Sorting -Employees");

        for (int i = 0; i < employees.length; i++) {
            System.out.println(employees[i]);
        }
        Arrays.sort(employees);
        System.out.println("After Sorting -Employees");
        for (int i = 0; i < employees.length; i++) {
            System.out.println(employees[i]);
        }
    }
}
............................................................................................

Sorting using java.util.Comparator


package com.sapient.ds.arrays;

import java.util.Comparator;

public class EmployeeIdAscendingOrder implements Comparator<Employee> {
    @Override
    public int compare(Employee employee1, Employee employee2) {
        return (employee1.getId() < employee2.getId()) ? -1 : ((employee1.getId() == employee2.getId()) ? 0 : 1);
    }
}


package com.sapient.ds.arrays;

import java.util.Comparator;

public class EmployeeIdDecendingOrder implements Comparator<Employee> {
    @Override
    public int compare(Employee employee1, Employee employee2) {
        return (employee1.getId() > employee2.getId()) ? -1 : ((employee1.getId() == employee2.getId()) ? 0 : 1);
    }
}
package com.sapient.ds.arrays;

import java.util.Arrays;

public class ArrayProcessing {
    public static void main(String[] args) {
        int[] list = {8, 3, 1, 2, 0, 4, 5};
        System.out.println("Before Sorting");
        for (int i = 0; i < list.length; i++) {
            System.out.println(list[i]);
        }
        Arrays.sort(list);
        System.out.println("After Sorting");
        for (int i = 0; i < list.length; i++) {
            System.out.println(list[i]);
        }
        Employee[] employees = {
                new Employee(4, "A"),
                new Employee(1, "B")
        };
        System.out.println("Before Sorting -Employees");

        for (int i = 0; i < employees.length; i++) {
            System.out.println(employees[i]);
        }
        Arrays.sort(employees);
        System.out.println("After Sorting -Employees");
        for (int i = 0; i < employees.length; i++) {
            System.out.println(employees[i]);
        }
        //using comparaator
        Employee[] employeeList = {
                new Employee(4, "A"),
                new Employee(5, "B"),
                new Employee(3, "C"),
                new Employee(1, "D"),
        };
        System.out.println("Before Sorting -Employees");

        for (int i = 0; i < employeeList.length; i++) {
            System.out.println(employeeList[i]);
        }
        Arrays.sort(employeeList, new EmployeeIdAscendingOrder());

        System.out.println("After Sorting -Employees");

        for (int i = 0; i < employeeList.length; i++) {
            System.out.println(employeeList[i]);
        }
        System.out.println("After Sorting Decending order -Employees");
        Arrays.sort(employeeList, new EmployeeIdDecendingOrder());

        for (int i = 0; i < employeeList.length; i++) {
            System.out.println(employeeList[i]);
        }
    }
}
..............................................................................................
























































































 
 











































































































  













 
   










































































































  
 

















































