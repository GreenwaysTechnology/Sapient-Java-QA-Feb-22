                                     Database
..............................................................................................

What is database?
  Collection of data stored in disk / in memory.

How to store data in computers?

=>file system
    Where information is stored

1960s program languages started coming to access the file and process file, prepare reports out of that.

eg:
 bank stores information about their customers and deposits and withdraws

1.bank asks who has deposited big amount today.
 Application developer writes code, process the file and gets data.
2.bank asks who has deposited big amount for this month
  Application developer writes code, process the file and gets data.


EF.Code who invented Realtion model for data storage and process based on realtional algeriabra.
Based on EF Code rule R Database management system was designed

Code Rules

1.
Rule 0: The foundation rule:

For any system that is advertised as, or claimed to be, a relational data base management system, that system must be able to manage data bases entirely through its relational capabilities.

Rule 1: The information rule:

All information in a relational data base is represented explicitly at the logical level and in exactly one way – by values in tables(Row-value)


Rule 2: The guaranteed access rule:

 Each and every datum (atomic value) in a relational data base is guaranteed to be logically accessible by resorting to a combination of table name, primary key value and column name.

Rule 3: Systematic treatment of null values:

Null values (distinct from the empty character string or a string of blank characters and distinct from zero or any other number) are supported in fully relational DBMS for representing missing information and inapplicable information in a systematic way, independent of data type.

Rule 4: Dynamic online catalog based on the relational model:

The data base description is represented at the logical level in the same way as ordinary data, so that authorized users can apply the same relational language to its interrogation as they apply to the regular data.

Rule 5: The comprehensive data sublanguage rule:

Rule 6:
 A relational system may support several languages and various modes of terminal use (for example, the fill-in-the-blanks mode). However, there must be at least one language whose statements are expressible, per some well-defined syntax, as character strings and that is comprehensive in supporting all of the following items:

Data definition.
View definition.
Data manipulation (interactive and by program).
Integrity constraints.
Authorization.
Transaction boundaries (begin, commit and rollback).

Rule 6: The view updating rule:

All views that are theoretically updatable are also updatable by the system.


Rule 7: Possible for high-level insert, update, and delete:

The capability of handling a base relation or a derived relation as a single operand applies not only to the retrieval of data but also to the insertion, update and deletion of data.

Rule 8: Physical data independence:

Application programs and terminal activities remain logically unimpaired whenever any changes are made in either storage representations or access methods.


Rule 9: Logical data independence:

Application programs and terminal activities remain logically unimpaired when information-preserving changes of any kind that theoretically permit unimpairment are made to the base tables.

Rule 10: Integrity independence:

Integrity constraints specific to a particular relational data base must be definable in the relational data sublanguage and storable in the catalog, not in the application programs.

Rule 11: Distribution independence:

The end-user must not be able to see that the data is distributed over various locations. Users should always get the impression that the data is located at one site only.

Rule 12: The nonsubversion rule:

If a relational system has a low-level (single-record-at-a-time) language, that low level cannot be used to subvert or bypass the integrity rules and constraints expressed in the higher level relational language (multiple-records-at-a-time).

.............................................................................................

Based on EF codd only, all relational databases were designed.

Databases:

1.IBM DB2
2.Oracle
3.Microsoft SQL server
4.MySql
etc....

NOSQL databases are more popular now a database
Mongodb
Redis
casendra
etc...
...........................................................................................
				 RealtionalDatabase

if you take any relational database, which is simply software only written either c or c++ ,java,javascript,python..

Every relational database internally uses file system to store data.

.............................................................................................
				   SEQL  -SQL

Structured English Query Language,Structured Query language, is programming language created by IBM in order to save,process data using commands
..............................................................................................
SQL language is common for the most of the database implemenations, but some extra commands or syntax for database to database may vary.
.............................................................................................
                        Database Design based on problem space /application domain
.............................................................................................
What is data models:

  Data models define how the logical structure of a database is modeled. Data Models are fundamental entities to introduce abstraction in a DBMS. Data models define how data is connected to each other and how they are processed and stored inside the system.

The very first data model could be flat data-models, where all the data used are to be kept in the same plane. Earlier data models were not so scientific, hence they were prone to introduce lots of duplication and update anomalies.



What is Normalization?
     In oo we call abstraction.
  
    Normalization is a database design technique that reduces data redundancy and eliminates undesirable characteristics like Insertion, Update and Deletion Anomalies. 

   Normalization rules divides larger tables into smaller tables and links them using relationships. The purpose of Normalisation in SQL is to eliminate redundant (repetitive) data and ensure data is stored logically.


Entity Relationship:

What is Entity?
   Object ,database Object which is collection of data items.

Entity-Relationship Model
   Entity-Relationship (ER) Model is based on the notion of real-world entities and relationships among them. While formulating real-world scenario into the database model, the ER Model creates entity set, relationship set, general attributes and constraints.


ER Model:

->Entites and its attributes
->Entity and its relationship with other entities

Entity − An entity in an ER Model is a real-world entity having properties called attributes. Every attribute is defined by its set of values called domain. For example, in a school database, a student is considered as an entity. Student has various attributes like name, age, class, etc.

Relationship − The logical association among entities is called relationship. Relationships are mapped with entities in various ways. Mapping cardinalities define the number of association between two entities.

Mapping cardinalities −

one to one
one to many
many to one
many to many
...........................................................................................
				Database schema
...........................................................................................

MySql is database software, can host many databases (schema) - plan
Schema is container object in database which contains other things
..........................................................................................
				 Database Objects


1.Schema
   Container Object which other objects
2.Table
    Object which stores data in row...column order
3.Views
4.Index
5.Stored Procedure
6.Tiger 
etc...
..............................................................................................
                                 Mysql 
..............................................................................................

What is MySQL?

Before MySQL all enterprise databases were not free like oracle,db2,microsoft sql server.
due to this many open source projects affected, The developer who is Michael, who started developing enterprise open source relational database called "MySql".

Later MySQL was acquired by Oracle,Oracle would said, MySQL continue in open source only if want  to for cost, we can offer enterprise support.


SQL basics :

SQL queries;
............
SQL Quries are classified into three category

1.DDL
2.DML
3.DCL/TCL

Data definition Language:

CREATE
ALTER
DROP
TRUNCATE
COMMENT
RENAME

CREATE command is used to create any database objects

schema,table,view,storedProcedure.....


create table:

CREATE TABLE [IF NOT EXISTS] table_name(
   column_1_definition,
   column_2_definition,
   ...,
   table_constraints
) ENGINE=storage_engine;

 The IF NOT EXISTS is optional. It allows you to check if the table that you create already exists in the database

you specify a list of columns of the table in the column_list section, columns are separated by commas.

Column defintions:

column_name data_type(length) [NOT NULL] [DEFAULT value] [AUTO_INCREMENT] column_constraint;



The column_name specifies the name of the column. 

Each column has a specific data type and optional size e.g.,VARCHAR(255) 


The  NOT NULL constraint ensures that the column will not contain NULL.

Besides the NOT NULL constraint, a column may have additional constraint such as CHECK, and UNIQUE.

The DEFAULT specifies a default value for the column.

The AUTO_INCREMENT  indicates that the value of the column is incremented by one automatically whenever a new row is inserted into the table.

Each table has a maximum one AUTO_INCREMENT column.


After the column list, you can define table constraints such as UNIQUE, CHECK, PRIMARY KEY and FOREIGN KEY.

Demo:

in order to create table we need schema.

How to create/drop schema

CREATE SCHEMA `sapient` ;
DROP DATABASE sapient

How to know the current database?

 SELECT database();
+------------+
| database() |
+------------+
| NULL       |
+------------+

NULL means no current  database selected

How to move to the current database.

mysql> use sapient;
Database changed
mysql> SELECT database();
+------------+
| database() |
+------------+
| sapient    |
+------------+
1 row in set (0.00 sec)

.............................................................................................

How to create table?

CREATE TABLE IF NOT EXISTS tasks (
    task_id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    start_date DATE,
    due_date DATE,
    status TINYINT NOT NULL,
    priority TINYINT NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)  ENGINE=INNODB;

How to list how many tables are there on single database?

mysql> show tables;
+-------------------+
| Tables_in_sapient |
+-------------------+
| tasks             |
+-------------------+
1 row in set (0.00 sec)


How to describe the table structure?

mysql> describe tasks;
+-------------+--------------+------+-----+-------------------+-------------------+
| Field       | Type         | Null | Key | Default           | Extra             |
+-------------+--------------+------+-----+-------------------+-------------------+
| task_id     | int          | NO   | PRI | NULL              | auto_increment    |
| title       | varchar(255) | NO   |     | NULL              |                   |
| start_date  | date         | YES  |     | NULL              |                   |
| due_date    | date         | YES  |     | NULL              |                   |
| status      | tinyint      | NO   |     | NULL              |                   |
| priority    | tinyint      | NO   |     | NULL              |                   |
| description | text         | YES  |     | NULL              |                   |
| created_at  | timestamp    | YES  |     | CURRENT_TIMESTAMP | DEFAULT_GENERATED |
+-------------+--------------+------+-----+-------------------+-------------------+

Every column has data types?

Numeric Data Types

-integers
 Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT
 Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC
 Floating-Point Types (Approximate Value) - FLOAT, DOUBLE
 Bit-Value Type - BIT

Date and Time Data Types
DATE
TIME
DATETIME
TIMESTAMP
YEAR

String Data Types
CHAR
VARVAR(SIZE)
BINARY
VARBINARY 
BLOB  - Binary large Objects - like images,videos
TEXT  -  large descriptions like para,blogs

Constraints:
 Rules for table columns

NOT Null
UNIQUE 
Primary Key
Foreign Key
Default 
Check

NOT Null:
The NOT NULL constraint is a column constraint that ensures values stored in a column are not NULL.

The syntax of defining a NOT NULL constraint is as follows:

column_name data_type NOT NULL;

CREATE TABLE tasks (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE
);

DML: INSERT - to add single row into the table

INSERT INTO table(c1,c2,...) VALUES (v1,v2,...);

mysql> describe tasks
    -> ;
+------------+--------------+------+-----+---------+----------------+
| Field      | Type         | Null | Key | Default | Extra          |
+------------+--------------+------+-----+---------+----------------+
| id         | int          | NO   | PRI | NULL    | auto_increment |
| title      | varchar(255) | NO   |     | NULL    |                |
| start_date | date         | NO   |     | NULL    |                |
| end_date   | date         | YES  |     | NULL    |                |
+------------+--------------+------+-----+---------+----------------+
4 rows in set (0.01 sec)

mysql> INSERT INTO tasks(title,start_date,end_date) VALUES('SQL Statements','2022-02-21','2022-02-21');
Query OK, 1 row affected (0.00 sec)

mysql> INSERT INTO tasks(title,start_date,end_date) VALUES(null,null,null);
ERROR 1048 (23000): Column 'title' cannot be null
mysql> INSERT INTO tasks(title) VALUES('MYSQL DB Statements');
ERROR 1364 (HY000): Field 'start_date' doesn't have a default value
mysql>
............................................................................................

UNIQUE Constraints:
...................
  in order to have unique values.

There are two ways to add constriant on columns

1.in the column defintion itself

CREATE TABLE table_name(
    ...,
    column_name data_type UNIQUE,
    ...
);

2.At end of the column list

CREATE TABLE table_name(
   ...
   column_name1 column_definition,
   column_name2 column_definition,
   ...,
   UNIQUE(column_name1,column_name2)
);

With help of constraint command

[CONSTRAINT constraint_name] UNIQUE(column_list)

Example :
CREATE TABLE suppliers (
    supplier_id INT AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    phone VARCHAR(15) NOT NULL UNIQUE,
    address VARCHAR(255) NOT NULL,
    PRIMARY KEY (supplier_id),
    CONSTRAINT uc_name_address UNIQUE (name , address)
);
 describe suppliers;
+-------------+--------------+------+-----+---------+----------------+
| Field       | Type         | Null | Key | Default | Extra          |
+-------------+--------------+------+-----+---------+----------------+
| supplier_id | int          | NO   | PRI | NULL    | auto_increment |
| name        | varchar(255) | NO   | MUL | NULL    |                |
| phone       | varchar(15)  | NO   | UNI | NULL    |                |
| address     | varchar(255) | NO   |     | NULL    |                |
+-------------+--------------+------+-----+---------+----------------+
4 rows in set (0.00 sec)

mysql> INSERT INTO suppliers(name,phone,address) VALUES('abc','100','city');
Query OK, 1 row affected (0.02 sec)

mysql> INSERT INTO suppliers(name,phone,address) VALUES('abcd','100','scity');
ERROR 1062 (23000): Duplicate entry '100' for key 'suppliers.phone'
mysql>
.............................................................................................

PRIMARY Key Constriant

PrimaryKey = not null + unquie


1.A primary key must contain unique values. 
2.If the primary key consists of multiple columns, the combination of values in these columns must be unique.
3.A primary key column cannot have NULL values.
4.Any attempt to insert or update NULL to primary key columns will result in an error.
 "Note that MySQL implicitly adds a NOT NULL constraint to primary key columns."
5.A table can have one an only one primary key.
6.Primary keys would be mostly sno...A primary key column often has the AUTO_INCREMENT attribute that automatically generates a sequential integer whenever you insert a new row into the table.

There are two ways to add constriant on columns

1.in the column defintion itself


CREATE TABLE table_name(
    primary_key_column datatype PRIMARY KEY,
    ...
);

2.At end of the column list

CREATE TABLE table_name(
    primary_key_column1 datatype,
    primary_key_column2 datatype,
    ...,
    PRIMARY KEY(column_list)
);

eg:
CREATE TABLE roles(
   role_id INT AUTO_INCREMENT,
   role_name VARCHAR(50),
   PRIMARY KEY(role_id)
);
INSERT INTO roles(role_name) VALUES('Manager');
Query OK, 1 row affected (0.01 sec)

mysql> INSERT INTO roles(role_name) VALUES('Manager');
Query OK, 1 row affected (0.00 sec)

mysql> SELECT * FROM roles;
+---------+-----------+
| role_id | role_name |
+---------+-----------+
|       1 | Manager   |
|       2 | Manager   |
+---------+-----------+
2 rows in set (0.00 sec)

mysql> INSERT INTO roles(role_id,role_name) VALUES('Manager');
ERROR 1136 (21S01): Column count doesn't match value count at row 1
mysql> INSERT INTO roles(role_id,role_name) VALUES(2,'teamlead');
ERROR 1062 (23000): Duplicate entry '2' for key 'roles.PRIMARY'
mysql> INSERT INTO roles(role_id,role_name) VALUES(null,'teamlead');
Query OK, 1 row affected (0.01 sec)

mysql> SELECT * FROM roles;
+---------+-----------+
| role_id | role_name |
+---------+-----------+
|       1 | Manager   |
|       2 | Manager   |
|       3 | teamlead  |
+---------+-----------+
3 rows in set (0.00 sec)
............................................................................................
			Constriants across the tables(Related tables only)
............................................................................................
foreign key:

  A foreign key is a column or group of columns in a table that links to a column or group of columns in another table. 

The foreign key places constraints on data in the related tables, which allows MySQL to maintain "referential integrity".

[CONSTRAINT constraint_name]
FOREIGN KEY [foreign_key_name] (column_name, ...)
REFERENCES parent_table(colunm_name,...)
[ON DELETE reference_option]
[ON UPDATE reference_option]

MySQL has five reference options: CASCADE, SET NULL, NO ACTION, RESTRICT, and SET DEFAULT.

CASCADE: if a row from the parent table is deleted or updated, the values of the matching rows in the child table automatically deleted or updated.

SET NULL:  if a row from the parent table is deleted or updated, the values of the foreign key column (or columns) in the child table are set to NULL.

RESTRICT:  if a row from the parent table has a matching row in the child table, MySQL rejects deleting or updating rows in the parent table.

NO ACTION: is the same as RESTRICT.

SET DEFAULT: is recognized by the MySQL parser. However, this action is rejected by both InnoDB and NDB tables.

CREATE TABLE categories(
    categoryId INT AUTO_INCREMENT PRIMARY KEY,
    categoryName VARCHAR(100) NOT NULL
);

CREATE TABLE products(
    productId INT AUTO_INCREMENT PRIMARY KEY,
    productName varchar(100) not null,
    categoryId INT,
    CONSTRAINT fk_category
    FOREIGN KEY (categoryId) 
        REFERENCES categories(categoryId)
);

...

INSERT INTO categories(categoryName) VALUES('Smartphone');

INSERT INTO products(productName, categoryId) VALUES('iPhone',1);
INSERT INTO products(productName, categoryId) VALUES('Samsung',4);

..............................................................................................

INSERT INTO categories(categoryName)
    -> VALUES
    ->     ('Smartphone'),
    ->     ('Smartwatch');
Query OK, 2 rows affected (0.01 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> INSERT INTO categories(categoryName) VALUES('Smartphone');
Query OK, 1 row affected (0.01 sec)

mysql> INSERT INTO products(productName, categoryId)
    -> VALUES('iPhone',1);
Query OK, 1 row affected (0.01 sec)

mysql> select *from categories;
+------------+--------------+
| categoryId | categoryName |
+------------+--------------+
|          1 | Smartphone   |
|          2 | Smartwatch   |
|          3 | Smartphone   |
+------------+--------------+
3 rows in set (0.00 sec)

mysql> select * from products;
+-----------+-------------+------------+
| productId | productName | categoryId |
+-----------+-------------+------------+
|         1 | iPhone      |          1 |
+-----------+-------------+------------+
1 row in set (0.01 sec)

mysql> INSERT INTO products(productName, categoryId) VALUES('iPad',3);
Query OK, 1 row affected (0.01 sec)

mysql> select * from products;
+-----------+-------------+------------+
| productId | productName | categoryId |
+-----------+-------------+------------+
|         1 | iPhone      |          1 |
|         2 | iPad        |          3 |
+-----------+-------------+------------+
2 rows in set (0.00 sec)

mysql> INSERT INTO products(productName, categoryId) VALUES('Samsung',4);
ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`sapient`.`products`, CONSTRAINT `fk_category` FOREIGN KEY (`categoryId`) REFERENCES `categories` (`categoryId`))
mysql>

Parent table update:

UPDATE categories SET categoryId = 100 WHERE categoryId = 1;

..............................................................................................
				Reference Options
.............................................................................................

CREATE TABLE products(productId INT AUTO_INCREMENT PRIMARY KEY,
    productName varchar(100) not null,
    categoryId INT NOT NULL,
    CONSTRAINT fk_category
    FOREIGN KEY (categoryId) 
    REFERENCES categories(categoryId)
        ON UPDATE CASCADE
        ON DELETE CASCADE
);


 INSERT INTO products(productName, categoryId)VALUES
    ->     ('iPhone', 1),
    ->     ('Galaxy Note',1),
    ->     ('Apple Watch',2),
    ->     ('Samsung Galary Watch',2);

Now update the Parent table:
 UPDATE categories SET categoryId = 100 WHERE categoryId = 1;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from categories;
+------------+--------------+
| categoryId | categoryName |
+------------+--------------+
|          2 | Smartwatch   |
|        100 | Smartphone   |
+------------+--------------+
2 rows in set (0.00 sec)

mysql> select * from products;
+-----------+----------------------+------------+
| productId | productName          | categoryId |
+-----------+----------------------+------------+
|         1 | iPhone               |        100 |
|         2 | Galaxy Note          |        100 |
|         3 | Apple Watch          |          2 |
|         4 | Samsung Galary Watch |          2 |
+-----------+----------------------+------------+
4 rows in set (0.00 sec)

When you delete a row, what will happen when casecade is on.
 DELETE FROM categories where categoryId=2
    -> ;
Query OK, 1 row affected (0.01 sec)

mysql> select * from categories;
+------------+--------------+
| categoryId | categoryName |
+------------+--------------+
|        100 | Smartphone   |
+------------+--------------+
1 row in set (0.00 sec)

mysql> select * from products;
+-----------+-------------+------------+
| productId | productName | categoryId |
+-----------+-------------+------------+
|         1 | iPhone      |        100 |
|         2 | Galaxy Note |        100 |
+-----------+-------------+------------+
2 rows in set (0.00 sec)
********************************************************************************************
DML Statements:

SELECT
INSERT 
UPDATE
DELETE

SELECT :

Single Column:

SELECT select_list FROM table_name;

SELECT lastName FROM employees;

Multi Column:

SELECT 
    lastName, 
    firstName, 
    jobTitle
FROM
    employees;

...........................................................................................
				SQL Clauses

Used to filter data

WHERE
ORDERBY
DISTINCT
groupby
having
etc.......

WHERE: 
  USED TO select row or rows based on boolean conditions

SELECT 
    select_list
FROM
    table_name
WHERE
    search_condition;

conditions can be :
operators:
equal
not equal
greater than, less than

select * from products WHERE productid=1;
+-----------+-------------+------------+
| productId | productName | categoryId |
+-----------+-------------+------------+
|         1 | iPhone      |        100 |
+-----------+-------------+------------+
.............................................................................................
				 SQL Joins
.............................................................................................

What is Join?

   A relational database consists of multiple related tables linking together using common columns, which are known as foreign key columns.
  Getting data from the multiple tables are called "joins".

Types of joins:

1.inner join
2.Left join
3.Right join
4.cross join


Demo:
CREATE TABLE members (
    member_id INT AUTO_INCREMENT,
    name VARCHAR(100),
    PRIMARY KEY (member_id)
);

CREATE TABLE committees (
    committee_id INT AUTO_INCREMENT,
    name VARCHAR(100),
    PRIMARY KEY (committee_id)
);

INSERT INTO members(name)
VALUES('John'),('Jane'),('Mary'),('David'),('Amelia');

INSERT INTO committees(name)
VALUES('John'),('Mary'),('Amelia'),('Joe');


INNER Join:
  joins two tables based on a condition which is known as join predicate(boolean condition)
  
  The inner join clause compares "each row from the first table" with every row from the second table

  First Table        second table
    1 one           =>    N rows

SELECT column_list
FROM table_1
INNER JOIN table_2 ON join_condition;

Note:
 when we combine two tables there might be two column names same, that time we need to which table data we want, "Column Alialse"  -  Reference name for the table.

SELECT columnName from table_name

SELECT SomeName.columnName from table_name as SomeName

eg:

SELECT 
    m.member_id, 
    m.name AS member, 
    c.committee_id, 
    c.name AS committee
FROM
    members m
INNER JOIN committees c ON c.name = m.name;


mysql> SELECT
    ->     m.member_id,
    ->     m.name AS member,
    ->     c.committee_id,
    ->     c.name AS committee
    -> FROM
    ->     members m
    -> INNER JOIN committees c ON 
+-----------+--------+--------------+-----------+
| member_id | member | committee_id | committee |
+-----------+--------+--------------+-----------+
|         1 | John   |            1 | John      |
|         3 | Mary   |            2 | Mary      |
|         5 | Amelia |            3 | Amelia    |
+-----------+--------+--------------+-----------+
3 rows in set (0.00 sec)
...............................................................................................

MySQL LEFT JOIN clause

  Similar to an inner join, a left join also requires a join predicate. When joining two tables using a left join, the concepts of left and right tables are introduced.

The left join selects data starting from the left table. For each row in the left table, the left join compares with every row in the right table.

Which displays all the data, if no match found, then unknown match values are treated or replaced with null values

SELECT column_list 
FROM table_1 
LEFT JOIN table_2 ON join_condition;


SELECT 
    m.member_id, 
    m.name AS member, 
    c.committee_id, 
    c.name AS committee
FROM
    members m
LEFT JOIN committees c ON c.name = m.name;

........................

 SELECT
    ->     m.member_id,
    ->     m.name AS member,
    ->     c.committee_id,
    ->     c.name AS committee
    -> FROM
    ->     members m
    -> LEFT JOIN committees c ON c.name = m.name;
+-----------+--------+--------------+-----------+
| member_id | member | committee_id | committee |
+-----------+--------+--------------+-----------+
|         1 | John   |            1 | John      |
|         2 | Jane   |         NULL | NULL      |
|         3 | Mary   |            2 | Mary      |
|         4 | David  |         NULL | NULL      |
|         5 | Amelia |            3 | Amelia    |
+-----------+--------+--------------+-----------+
5 rows in set (0.00 sec)
............................................................................................

RIGHT JOIN clause

  The right join clause is similar to the left join clause except that the treatment of left and right tables is reversed. 

The right join starts selecting data from the right table instead of the left table.

The right join clause selects all rows from the right table and matches rows in the left table.

 If a row from the right table does not have matching rows from the left table, the column of the left table will have NULL in the final result set.


SELECT column_list 
FROM table_1 
RIGHT JOIN table_2 ON join_condition;
SELECT
    ->     m.member_id,
    ->     m.name AS member,
    ->     c.committee_id,
    ->     c.name AS committee
    -> FROM
    ->     members m
    -> RIGHT JOIN committees c ON c.name = m.name;
+-----------+--------+--------------+-----------+
| member_id | member | committee_id | committee |
+-----------+--------+--------------+-----------+
|         1 | John   |            1 | John      |
|         3 | Mary   |            2 | Mary      |
|         5 | Amelia |            3 | Amelia    |
|      NULL | NULL   |            4 | Joe       |
+-----------+--------+--------------+-----------+
4 rows in set (0.00 sec)
.............................................................................................

Self Join
The syntax of self-join is the same as the syntax of joining two different tables.
Here, we use aliases name for tables because both the table name are the same. The following are the syntax of a SELF JOIN in MySQL:

SELECT s1.col_name, s2.col_name...  
FROM table1 s1, table1 s2  
WHERE s1.common_col_name = s2.common_col_name;  


Select m1.name , m2.name from members m1 , members m2 where  m1.member_id= m2.member_id;
+--------+--------+
| name   | name   |
+--------+--------+
| John   | John   |
| Jane   | Jane   |
| Mary   | Mary   |
| David  | David  |
| Amelia | Amelia |
+--------+--------+
5 rows in set (0.00 sec)
.............................................................................................
				MY SQL Functions
...............................................................................................
Aggregate Functions 
 Average(), Count(), Maximum() 
 Median(), Minimum(), Mode(), Sum() 
https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html

use classicmodels
 SELECT * FROM classicmodels.products;

avg
SELECT
    ->     AVG(buyprice) 'Average Classic Cars Price'
    -> FROM
    ->     products
    -> WHERE
    ->     productline = 'Classic Cars';
+----------------------------+
| Average Classic Cars Price |
+----------------------------+
|                  64.446316 |
+----------------------------+
1 row in set (0.01 sec)

max:
SELECT productName, MIN(buyprice), MAX(buyPrice) FROM products;
+---------------------------------------+---------------+---------------+
| productName                           | MIN(buyprice) | MAX(buyPrice) |
+---------------------------------------+---------------+---------------+
| 1969 Harley Davidson Ultimate Chopper |         15.91 |        103.42 |
+---------------------------------------+---------------+---------------+
1 row in set (0.00 sec)

.............................................................................................
				Grouping data

groupby, orderby having

Groupby:
 if you want to get summary of data
  The GROUP BY clause groups a set of rows into a set of summary rows by values of columns or expressions.

 The GROUP BY clause returns one row for each group. 
  In other words, it reduces the number of rows in the result set.

phone
  ...
ipad
  ...
computers
  
SELECT 
    c1, c2,..., cn, aggregate_function(ci)
FROM
    table
WHERE
    where_conditions
GROUP BY c1 , c2,...,cn;

SELECT 
    status
FROM
    orders
GROUP BY status;
..............................................................................................

ORDER BY clause
   When you use the SELECT statement to query data from a table, the order of rows in the result set is unspecified.
  To sort the rows in the result set, you add the ORDER BY clause to the SELECT statement.

The following illustrates the syntax of the ORDER BY clause:

SELECT 
   select_list
FROM 
   table_name
ORDER BY 
   column1 [ASC|DESC], 
   column2 [ASC|DESC],
   ...;

SELECT
	contactLastname,
	contactFirstname
FROM
	customers
ORDER BY
	contactLastname; 

The above one is asyn order.


mysql> SELECT
    -> contactLastname,
    -> contactFirstname
    -> FROM
    -> customers
    -> ORDER BY
    -> contactLastname desc;
.............................................................................................
				Groupby with Condition

  The HAVING clause is used in the SELECT statement to specify filter conditions for a group of rows or aggregates.

The HAVING clause is often used with the GROUP BY clause to filter groups based on a specified condition. If you omit the GROUP BY clause, the HAVING clause behaves like the WHERE clause.

The following illustrates the syntax of the HAVING clause:

SELECT 
    select_list
FROM 
    table_name
WHERE 
    search_condition
GROUP BY 
    group_by_expression
HAVING 
    group_condition;

SELECT 
    ordernumber,
    SUM(quantityOrdered) AS itemsCount,
    SUM(priceeach*quantityOrdered) AS total
FROM
    orderdetails
GROUP BY 
   ordernumber
HAVING 
   total > 100 and total < 5000;

SELECT
    ->     ordernumber,
    ->     SUM(quantityOrdered) AS itemsCount,
    ->     SUM(priceeach*quantityOrdered) AS total
    -> FROM
    ->     orderdetails
    -> GROUP BY
    ->    ordernumber
    -> HAVING
    ->    total > 100 and total < 5000;
+-------------+------------+---------+
| ordernumber | itemsCount | total   |
+-------------+------------+---------+
|       10116 |         27 | 1627.56 |
|       10118 |         36 | 3101.40 |
|       10132 |         36 | 2880.00 |
|       10144 |         20 | 1128.20 |
|       10154 |         67 | 4465.85 |
|       10156 |         68 | 4599.52 |
|       10158 |         22 | 1491.38 |
|       10189 |         28 | 3879.96 |
|       10242 |         46 | 1679.92 |
|       10255 |         61 | 4632.31 |
|       10256 |         63 | 4710.73 |
|       10277 |         28 | 2611.84 |
|       10286 |         38 | 1960.80 |
|       10294 |         45 | 4424.40 |
|       10303 |         70 | 3474.66 |
|       10317 |         35 | 2434.25 |
|       10345 |         43 | 1676.14 |
|       10364 |         48 | 1834.56 |
|       10376 |         35 | 3452.75 |
|       10385 |         62 | 4466.71 |
|       10387 |         44 | 3516.04 |
|       10408 |         15 |  615.45 |
|       10409 |         67 | 2326.18 |
+-------------+------------+---------+
23 rows in set (0.00 sec)
.............................................................................................
				Database objects


1.index
2.views
3.storedprocedures and functions
4.tiggers
5.transactions

index:
 index is object used on table columns used to perform fast data reterival.
   An index is a data structure such as B-Tree that improves the speed of data retrieval on a table at the cost of additional writes and storage to maintain it.

how to add index?

inside table definition

CREATE TABLE t(
   c1 INT PRIMARY KEY,
   c2 INT NOT NULL,
   c3 INT NOT NULL,
   c4 VARCHAR(10),
   INDEX (c2,c3) 
);

outside table definition:

 CREATE INDEX index_name ON table_name (column_list)

SELECT 
    employeeNumber, 
    lastName, 
    firstName
FROM
    employees
WHERE
    jobTitle = 'Sales Rep';

CREATE INDEX jobTitle ON employees(jobTitle);

SHOW INDEXES FROM employees;
.............................................................................................

Views:

  Views are like table, but can be used only query reterival.

Why Views?

SELECT 
    customerName, 
    checkNumber, 
    paymentDate, 
    amount
FROM
    customers
INNER JOIN
    payments USING (customerNumber);

Views are used to abstract complex query operations?

CREATE VIEW viewName select statement;

CREATE VIEW customerPayments
AS 
SELECT 
    customerName, 
    checkNumber, 
    paymentDate, 
    amount
FROM
    customers
INNER JOIN
    payments USING (customerNumber);


SELECT *FROM customerPayments.
..............................................................................................
Triggers:

In MySQL, a trigger is a stored program invoked automatically in response to an event such as insert, update, or delete that occurs in the associated table. 

MySQL supports triggers that are invoked in response to the INSERT, UPDATE or DELETE event.

The SQL standard defines two types of triggers:

row-level triggers and statement-level triggers.

A row-level trigger is activated for each row that is inserted, updated, or deleted.  For example, if a table has 100 rows inserted, updated, or deleted, the trigger is automatically invoked 100 times for the 100 rows affected.

A statement-level trigger is executed once for each transaction regardless of how many rows are inserted, updated, or deleted.

Advantages of triggers
Triggers provide another way to check the integrity of data.
Triggers handle errors from the database layer.
Triggers give an alternative way to run scheduled tasks. By using triggers, you don’t have to wait for the scheduled events to run because the triggers are invoked automatically before or after a change is made to the data in a table.
Triggers can be useful for auditing the data changes in tables.

How to create Trigger?

CREATE TRIGGER trigger_name
{BEFORE | AFTER} {INSERT | UPDATE| DELETE }
ON table_name FOR EACH ROW
trigger_body;


CREATE TABLE employees_audit (
    id INT AUTO_INCREMENT PRIMARY KEY,
    employeeNumber INT NOT NULL,
    lastname VARCHAR(50) NOT NULL,
    changedat DATETIME DEFAULT NULL,
    action VARCHAR(50) DEFAULT NULL
);

CREATE TRIGGER before_employee_update 
    BEFORE UPDATE ON employees
    FOR EACH ROW 
 INSERT INTO employees_audit
 SET action = 'update',
     employeeNumber = OLD.employeeNumber,
     lastname = OLD.lastname,
     changedat = NOW();


Update the employee table;

UPDATE employees 
SET 
    lastName = 'Phan'
WHERE
    employeeNumber = 1056;


mysql> UPDATE employees
    -> SET
    ->     lastName = 'Phan'
    -> WHERE
    ->     employeeNumber = 1056;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select lastName from employees where employeeNumber=1056
    -> ;
+----------+
| lastName |
+----------+
| Phan     |
+----------+
1 row in set (0.00 sec)

mysql> SELECT *FROM employees_audit;
+----+----------------+-----------+---------------------+--------+
| id | employeeNumber | lastname  | changedat           | action |
+----+----------------+-----------+---------------------+--------+
|  1 |           1056 | Patterson | 2022-02-21 16:44:44 | update |
+----+----------------+-----------+---------------------+--------+
1 row in set (0.00 sec)
..............................................................................................
				Stored Procedures
.............................................................................................
Stored Procedures are methods/functions having biz logic + comibing sql statements.
Inside write complex biz logic in the client side, we can write the same in the database itself.

How to create Stored procedures?

DELIMITER $$
CREATE PROCEDURE GetCustomers()
BEGIN
	SELECT 
		customerName, 
		city, 
		state, 
		postalCode, 
		country
	FROM
		customers
	ORDER BY customerName;    
END$$
DELIMITER ;

Invoke Stored procedure:

CALL GetCustomers();
..............................................................................................
Stored Procedures:

IN parameters
 IN is the default mode. When you define an IN parameter in a stored procedure, the calling program has to pass an argument to the stored procedure.

In addition, the value of an IN parameter is protected. It means that even you change the value of the IN parameter inside the stored procedure, its original value is unchanged after the stored procedure ends. In other words, the stored procedure only works on the copy of the IN parameter.

OUT parameters(Return values):
 The value of an OUT parameter can be changed inside the stored procedure and its new value is passed back to the calling program.

Notice that the stored procedure cannot access the initial value of the OUT parameter when it starts.

INOUT parameters (input and return)
An INOUT  parameter is a combination of IN and OUT parameters. It means that the calling program may pass the argument, and the stored procedure can modify the INOUT parameter, and pass the new value back to the calling program.

[IN | OUT | INOUT] parameter_name datatype[(length)]

DELIMITER //

CREATE PROCEDURE GetOfficeByCountry(
	IN countryName VARCHAR(255)
)
BEGIN
	SELECT * 
 	FROM offices
	WHERE country = countryName;
END //

DELIMITER ;

CALL getOfficeByCountry('France');
..............................................................................................
				   Trancations and Locks
..............................................................................................

What is transaction?
  A sequence of statement execution, during statement execution if something goes wrong in the middle, i dont want to continue the steps and cancel previous actions.

for eg:
  online purchase

1.purchase is success, purchase table got updated
2.payment is failed, i could not insert data in the payment table and also i have to revoke the purchase table.


By default, transaction is disabled in databse.

we need to enable transaction features.

SET autocommit = ON; 


-- 1. start a new transaction
START TRANSACTION;

-- 2. Get the latest order number
SELECT 
    @orderNumber:=MAX(orderNUmber)+1
FROM
    orders;

-- 3. insert a new order for customer 145
INSERT INTO orders(orderNumber,
                   orderDate,
                   requiredDate,
                   shippedDate,
                   status,
                   customerNumber)
VALUES(@orderNumber,
       '2005-05-31',
       '2005-06-10',
       '2005-06-11',
       'In Process',
        145);
        
-- 4. Insert order line items
INSERT INTO orderdetails(orderNumber,
                         productCode,
                         quantityOrdered,
                         priceEach,
                         orderLineNumber)
VALUES(@orderNumber,'S18_1749', 30, '136', 1),
      (@orderNumber,'S18_2248', 50, '55.09', 2); 
      
-- 5. commit changes    
COMMIT;



mysql> START TRANSACTION;
Query OK, 0 rows affected (0.00 sec)

mysql> DELETE FROM orders;
Query OK, 327 rows affected (0.03 sec)


mysql> rollback;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from user;
+----+-------------------------------+--------------+
| id | email                         | name         |
+----+-------------------------------+--------------+
|  1 | sasubramanian_md@hotmail.com  | subramanian  |
|  2 | sasubramanian1_md@hotmail.com | subramanian1 |
+----+-------------------------------+--------------+

mysql> commit;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from user;
Empty set (0.00 sec)

mysql>


rollback : 
   you can get the data where ever last until commited data.

commit :
  you are conforming the what ever the transactions you did.
.....................................&&&&&&&&&&&&&&&&&&&&&&&&................................
 







